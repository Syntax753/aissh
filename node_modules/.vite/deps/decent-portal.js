import {
  require_react_dom
} from "./chunk-AUFLGUIX.js";
import {
  require_react
} from "./chunk-PSQR3SVX.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/decent-portal/dist/decent-portal.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
!function() {
  "use strict";
  try {
    if ("undefined" != typeof document) {
      var o = document.createElement("style");
      o.appendChild(document.createTextNode('._container_13zim_6{display:flex;grid-area:header;width:100%;height:5vh}._decentFacet_13zim_14{background-color:#000;width:8.5vh;clip-path:polygon(0 0,100% 0,calc(100% - 5vh) 100%,0% 100%);margin-right:-5vh}._appFacet_13zim_21{background:linear-gradient(#c57431,#222);clip-path:polygon(5vh 0,100% 0,calc(100% - 5vh) 100%,0% 100%);margin-right:-6.1vh;padding-right:6vh;display:inline-block;color:#fff;position:relative}._appName_13zim_31{padding-left:5.5vh;padding-right:7vh;font-size:4vh;-webkit-text-fill-color:white;-webkit-text-stroke-width:.2vh;-webkit-text-stroke-color:#222222;font-family:hobby-of-night;display:inline-block;overflow-x:visible;white-space:nowrap}._appButtonArea_13zim_44{display:inline-block;height:100%;margin-left:-4vh}._appFacetSeparator_13zim_50{background-color:#000;width:6vh;margin-right:-5.5vh;clip-path:polygon(5vh 0,100% 0,calc(100% - 5vh) 100%,0% 100%)}._contributorFacet_13zim_57{background:linear-gradient(#ddd,#222);flex:1;clip-path:polygon(5vh 0,100% 0,100% 100%,0% 100%);margin-right:-5vh;padding-left:5vh;position:relative;color:#555;font-size:1vh}._favIcon_13zim_68{position:relative;top:.5vh;left:.5vh;height:4vh}._settingsIcon_13zim_75{position:absolute;top:.5vh;right:6vh;height:4vh;width:4vh;cursor:pointer}._contentButton_rhsdb_6{justify-content:center;background-color:#c57431;border-style:none;background-position:center;transition:background .2s;cursor:pointer;margin-right:.1vh;margin-bottom:.1vh;padding-left:.2vh;padding-right:.2vh}._contentButton_rhsdb_6:hover{background:#e68a40 radial-gradient(circle,transparent 1%,#c57431 1%) center/23000%}._contentButton_rhsdb_6:active{background-color:#e68a40;background-size:100%;transition:background 0s}._contentButtonText_rhsdb_29{font-size:1.4vh;letter-spacing:.1vh;color:#fff}._contentButtonDisabled_rhsdb_35{background-color:gray;cursor:default}._contentButtonDisabled_rhsdb_35:hover{background:gray}._contentButtonTextDisabled_rhsdb_45{color:#d3d3d3}._fullscreenOverlay_nh884_4{position:fixed;width:100%;height:100%;inset:0;background-color:#000c;z-index:2}._clickable_nh884_16{cursor:pointer}._dialog_nh884_20{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:50%;background-color:#fff;border-style:solid;border-radius:1rem;border-width:.6rem;padding:2rem;font-size:1.5rem;cursor:default}._dialog_nh884_20>h1{text-align:center;margin-bottom:2rem;font-size:1.5rem;margin-top:0;width:100%;background-color:#ffe9d7;padding:.5rem}._bar_c4j8c_6{display:flex;justify-content:flex-start;align-items:stretch;flex-wrap:wrap}._label_c4j8c_13{flex-grow:0;min-width:7vh;padding-left:.5vh;padding-right:.5vh;font-size:1.3vh}._selectorButton_c4j8c_22{justify-content:center;background-color:#c57431;border-style:none solid none none;border-color:#aa6226;background-position:center;transition:background .2s;cursor:pointer;margin-bottom:.1vh}._tabButton_c4j8c_34{border-top-left-radius:.5vh;border-top-right-radius:.5vh;margin-bottom:0;margin-right:.1vh}._selectorButton_c4j8c_22:hover{background:#e68a40 radial-gradient(circle,transparent 1%,#c57431 1%) center/23000%}._selectorButton_c4j8c_22:active{background-color:#e68a40;background-size:100%;transition:background 0s}._firstSelectorButton_c4j8c_50{border-top-left-radius:.5vh;border-bottom-left-radius:.5vh}._lastSelectorButton_c4j8c_55{border-top-right-radius:.5vh;border-bottom-right-radius:.5vh}._selectorButtonText_c4j8c_60{padding-left:.5vh;padding-right:.5vh;letter-spacing:.1vh;font-size:1.1vh;color:#fff}._selectorButtonSelected_c4j8c_68{background-color:#e68a40;cursor:default}._icon_c4j8c_74{display:inline-block;height:1.1vh;font-size:1vh;padding-left:.3vh;color:#fff;cursor:default}._iconDisabled_c4j8c_83{cursor:pointer}._selectorButtonSelectedReclickable_c4j8c_88{background-color:#e68a40;cursor:pointer}._selectorButtonSelected_c4j8c_68:hover{background-color:#e68a40}._selectorButtonTextSelected_c4j8c_98{color:#fff}._selectorButtonDisabled_c4j8c_103{background-color:gray;cursor:pointer}._selectorButtonDisabled_c4j8c_103:hover,._selectorButtonDisabled_c4j8c_103:active{background-color:gray}._selectorButtonTextDisabled_c4j8c_116{color:#d3d3d3}._container_iv4ss_1{position:relative;display:inline-block}._contentBox_iv4ss_6{position:fixed;background-color:#faebd7;width:25vh;left:0;top:0;border-color:#000;border-width:.2vh;border-radius:1vh;border-style:solid;box-shadow:0 .5vh 1vh #0000001a;z-index:10}._container_1dxqw_4{height:50vh;border-color:#e68a40;border-style:solid;border-width:.2vh;border-image:linear-gradient(to bottom,#e68a40,#fdebd7) 1;background-color:#f9f9f8;overflow-x:hidden;overflow-y:hidden}._container_1dxqw_4>p{font-size:1.4vh;padding-top:1vh;padding-left:.5vh;padding-right:.5vh;margin-bottom:1vh;background:linear-gradient(to bottom,#e68a40,#f9f9f8 80% 100%)}._setterList_1dxqw_29{position:relative;overflow-y:auto;overflow-x:hidden;height:46vh;box-sizing:border-box}._setterList_1dxqw_29:hover{scrollbar-color:#c57431 white}._container_1vhj3_4{font-size:1vh;display:flex;margin-bottom:.5vh}._container_1vhj3_4>input{font-size:1vh}._label_1vhj3_14{margin-left:1vh;margin-right:1vh;min-width:15vw;display:inline-block;font-size:1vh}._labelDisabled_1vhj3_22{color:gray}._heading_1vhj3_27{padding-left:.5vh;margin-bottom:1vh;background:linear-gradient(to bottom,#ffe6c1,#f9f9f8)}._headingDisabled_1vhj3_37{color:gray;background:linear-gradient(to bottom,#e1e1e1,#f9f9f8)}._heading_1vhj3_27>p{font-size:1.1vh;font-weight:700;padding-top:.5vh;padding-bottom:0}._heading_1vhj3_27>hr{margin:0;border:none;height:.1vh;background-color:#e68a40}._validationMessage_1vhj3_61{margin-left:1vh;padding-top:.1vh;font-size:.8vh;color:red}._validationMessage_1vhj3_61:before{content:"â¬… "}._container_1vhj3_4 input:focus,button:focus{outline:none;border-color:#e68a40;box-shadow:0 0 .5vh #e68a40}._headingButton_1gpxc_6{justify-content:center;background-color:#c57431;border-style:none;background-position:center;transition:background .2s;cursor:pointer;margin-right:.3vh;margin-bottom:.1vh;padding-left:.3vh;padding-right:.3vh}._headingButton_1gpxc_6:hover{background:#e68a40 radial-gradient(circle,transparent 1%,#c57431 1%) center/23000%}._headingButton_1gpxc_6:active{background-color:#e68a40;background-size:100%;transition:background 0s}._headingButtonText_1gpxc_29{font-size:.9vh;letter-spacing:.1vh;color:#fff}._headingButtonDisabled_1gpxc_35{background-color:gray;cursor:default}._headingButtonDisabled_1gpxc_35:hover{background:gray}._headingButtonTextDisabled_1gpxc_45{color:#d3d3d3}._container_t15oa_1 p{padding:.5vh 1vh;font-size:1vh}._modelIdText_t15oa_9{padding-left:1vh;padding-right:1vh;padding-bottom:.2vh;background-color:#fff;border-top-left-radius:1vh;border-top-right-radius:1vh;text-align:center;font-size:1vh}._appBehaviorSummary_t15oa_20{padding-top:.5vh;padding-bottom:0;font-style:italic;font-size:1vh}._speedContainer_t15oa_27{width:100%;padding:.5vh;padding-top:0}._container_dabnx_1{display:inline-flex}._speedBox_dabnx_5{border:1px solid black;align-items:center;position:relative;overflow:hidden;font-size:1vh;color:#000;padding-left:.5vh;padding-right:.5vh}._progressBar_dabnx_16{position:absolute;bottom:0;left:0;height:100%;z-index:-1}._overTextBar_dabnx_24{position:absolute;bottom:0;right:0;height:100%;background-color:#ffffffe6;z-index:1;pointer-events:none}._inputSpeedBox_dabnx_34{background-color:#e6b489;border-right:0}._outputSpeedBox_dabnx_40{background-color:#fdc28d}._problemList_1a0tc_4{margin:.5vh 2vh}._problemList_1a0tc_4 li{display:flex;align-items:center;font-size:1vh;min-height:2vh;margin-bottom:.5vh;margin-right:.5vh}._icon_1a0tc_20{width:2vh;margin-right:.5vh}._container_1ldt5_1{width:100%;display:flex;justify-content:flex-end;margin-top:.5rem}._dialogButton_1e5oo_6{flex-basis:10vh;justify-content:center;background-color:#c57431;border-style:none;background-position:center;transition:background .2s;cursor:pointer;margin-right:.1vh;margin-bottom:.1vh}._dialogButton_1e5oo_6:hover{background:#e68a40 radial-gradient(circle,transparent 1%,#c57431 1%) center/23000%}._dialogButton_1e5oo_6:active{background-color:#e68a40;background-size:100%;transition:background 0s}._dialogButtonText_1e5oo_28{letter-spacing:.1vh;font-size:1.4vh;color:#fff}._dialogButtonDisabled_1e5oo_34{background-color:gray;cursor:default}._dialogButtonDisabled_1e5oo_34:hover{background:gray}._dialogButtonTextDisabled_1e5oo_44{color:#d3d3d3}._dialogButtonPrimary_1e5oo_49{background-color:#ff850b;border-style:solid;border-width:.1vh;border-color:#ba7840;box-sizing:border-box}._disableSelect_mpqe1_1{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}._container_hyytp_4{width:100%;height:calc(100% - .3rem);position:fixed;left:0;top:0;margin-left:5rem;margin-right:5rem;display:flex;flex-direction:column-reverse;pointer-events:none;z-index:1000}._container_10gzw_3{background-color:gray;width:calc(100% - 12rem);border-radius:1rem;border-color:#b08859;border-style:solid;border-width:.1rem;margin-bottom:.1rem;cursor:pointer;padding-left:3rem;padding-right:3rem;display:table;pointer-events:all}._container_10gzw_3>p{font-size:1.5rem;text-align:center;vertical-align:middle;display:table-cell}._containerError_10gzw_26{background-color:#ff6060}._containerInfo_10gzw_31{background-color:#e9c5a7}._containerImportant_10gzw_36{background-color:#f6e3a1}@keyframes _appear_10gzw_1{0%{opacity:0}to{opacity:100%}}@keyframes _disappear_10gzw_1{0%{opacity:100%}to{opacity:0}}._containerAppear_10gzw_51{animation:_appear_10gzw_1 1s;animation-fill-mode:forwards}._containerDisappear_10gzw_56{animation:_disappear_10gzw_1 1s;animation-fill-mode:forwards}._dismissIcon_10gzw_61{float:right;margin-right:-2rem;margin-top:.5rem;margin-bottom:.5rem;font-size:1rem;color:#444;cursor:pointer}._continueText_rt9ep_4{margin-bottom:2vh}._modelIdText_rt9ep_8{font-size:1.5vh;background-color:#f9f9f8;border-radius:.5vh;padding:.2vh;white-space:nowrap}._problemPanel_rt9ep_16{padding:2vh}')), document.head.appendChild(o);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
}();
var jsxRuntime = { exports: {} };
var reactJsxRuntime_development = {};
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  (function() {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch ("number" === typeof type.tag && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return false;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          displayName
        ));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
      self2 = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self2, debugStack, debugTask) {
      var children = config.children;
      if (void 0 !== children)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function(k) {
          return "key" !== k;
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
          'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
          isStaticChildren,
          children,
          keys,
          children
        ), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children && defineKeyPropWarningGetter(
        maybeKey,
        "function" === typeof type ? type.displayName || type.name || "Unknown" : type
      );
      return ReactElement(
        type,
        children,
        self2,
        source,
        getOwner(),
        maybeKey,
        debugStack,
        debugTask
      );
    }
    function validateChildKeys(node) {
      "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = import_react.default, REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(
      React,
      UnknownOwner
    )();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_development.jsx = function(type, config, maybeKey, source, self2) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        false,
        source,
        self2,
        trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
    reactJsxRuntime_development.jsxs = function(type, config, maybeKey, source, self2) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        true,
        source,
        self2,
        trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
  })();
  return reactJsxRuntime_development;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  if (false) {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  } else {
    jsxRuntime.exports = requireReactJsxRuntime_development();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var container$7 = "_container_13zim_6 _disableSelect_mpqe1_1";
var decentFacet = "_decentFacet_13zim_14";
var appFacet = "_appFacet_13zim_21";
var appName = "_appName_13zim_31";
var appButtonArea = "_appButtonArea_13zim_44";
var appFacetSeparator = "_appFacetSeparator_13zim_50";
var contributorFacet = "_contributorFacet_13zim_57";
var favIcon = "_favIcon_13zim_68";
var settingsIcon = "_settingsIcon_13zim_75";
var styles$f = {
  container: container$7,
  decentFacet,
  appFacet,
  appName,
  appButtonArea,
  appFacetSeparator,
  contributorFacet,
  favIcon,
  settingsIcon
};
var contentButton = "_contentButton_rhsdb_6 _disableSelect_mpqe1_1";
var contentButtonText = "_contentButtonText_rhsdb_29";
var contentButtonDisabled = "_contentButtonDisabled_rhsdb_35 _contentButton_rhsdb_6 _disableSelect_mpqe1_1";
var contentButtonTextDisabled = "_contentButtonTextDisabled_rhsdb_45 _contentButtonText_rhsdb_29";
var styles$e = {
  contentButton,
  contentButtonText,
  contentButtonDisabled,
  contentButtonTextDisabled
};
function ContentButton(props) {
  const { text, onClick, disabled } = props;
  const buttonClass = disabled ? styles$e.contentButtonDisabled : styles$e.contentButton;
  const textClass = disabled ? styles$e.contentButtonTextDisabled : styles$e.contentButtonText;
  return jsxRuntimeExports.jsx("button", { className: buttonClass, onClick, disabled, children: jsxRuntimeExports.jsx("span", { className: textClass, children: text }) });
}
function isServingFromEnabledDomain(enabledDomains) {
  const currentDomain = window.location.hostname.toLowerCase();
  return enabledDomains.some((domain) => currentDomain === domain.toLowerCase() || currentDomain.endsWith(`.${domain.toLowerCase()}`));
}
function getBaseUrl() {
  const url = new URL(window.location.href);
  return `${url.protocol}//${url.hostname}${url.port ? `:${url.port}` : ""}`;
}
var SettingsIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M12,15.5A3.5,3.5%200%200,1%208.5,12A3.5,3.5%200%200,1%2012,8.5A3.5,3.5%200%200,1%2015.5,12A3.5,3.5%200%200,1%2012,15.5M19.43,12.97C19.47,12.65%2019.5,12.33%2019.5,12C19.5,11.67%2019.47,11.34%2019.43,11L21.54,9.37C21.73,9.22%2021.78,8.95%2021.66,8.73L19.66,5.27C19.54,5.05%2019.27,4.96%2019.05,5.05L16.56,6.05C16.04,5.66%2015.5,5.32%2014.87,5.07L14.5,2.42C14.46,2.18%2014.25,2%2014,2H10C9.75,2%209.54,2.18%209.5,2.42L9.13,5.07C8.5,5.32%207.96,5.66%207.44,6.05L4.95,5.05C4.73,4.96%204.46,5.05%204.34,5.27L2.34,8.73C2.21,8.95%202.27,9.22%202.46,9.37L4.57,11C4.53,11.34%204.5,11.67%204.5,12C4.5,12.33%204.53,12.65%204.57,12.97L2.46,14.63C2.27,14.78%202.21,15.05%202.34,15.27L4.34,18.73C4.46,18.95%204.73,19.03%204.95,18.95L7.44,17.94C7.96,18.34%208.5,18.68%209.13,18.93L9.5,21.58C9.54,21.82%209.75,22%2010,22H14C14.25,22%2014.46,21.82%2014.5,21.58L14.87,18.93C15.5,18.67%2016.04,18.34%2016.56,17.94L19.05,18.95C19.27,19.03%2019.54,18.95%2019.66,18.73L21.66,15.27C21.78,15.05%2021.73,14.78%2021.54,14.63L19.43,12.97Z'%20/%3e%3c/svg%3e";
var fullscreenOverlay = "_fullscreenOverlay_nh884_4";
var clickable = "_clickable_nh884_16";
var dialog = "_dialog_nh884_20";
var styles$d = {
  fullscreenOverlay,
  clickable,
  dialog
};
function _doNothing(event) {
  event.stopPropagation();
}
function ModalDialog(props) {
  if (!props.isOpen) return null;
  const { children, onCancel, title } = props;
  const fullscreenOverlayStyle = `${styles$d.fullscreenOverlay} ${onCancel ? styles$d.clickable : ""}`;
  return jsxRuntimeExports.jsx("div", { className: fullscreenOverlayStyle, onMouseDown: onCancel, children: jsxRuntimeExports.jsxs("div", { className: styles$d.dialog, onClick: _doNothing, onMouseDown: _doNothing, children: [
    jsxRuntimeExports.jsx("h1", { children: title }),
    children
  ] }) });
}
var HEADING_TYPE = "HEADING";
function duplicateHeading(heading2) {
  return {
    ...heading2,
    buttons: heading2.buttons ? [...heading2.buttons] : void 0
  };
}
function isSettingValuesFormat(maybeValues) {
  return !!maybeValues && typeof maybeValues === "object" && !Array.isArray(maybeValues) && Object.keys(maybeValues).every(
    (key) => typeof key === "string" && (typeof maybeValues[key] === "number" || typeof maybeValues[key] === "string" || typeof maybeValues[key] === "boolean")
  );
}
function keyToPath(key) {
  const pathEnd = key.lastIndexOf("/") + 1;
  return key.substring(0, pathEnd);
}
var MIMETYPE_PLAIN_TEXT = "text/plain";
var SCHEMA_VERSION = 1;
var APP_DATA_VERSION = 1;
var DB_NAME = `DecentPortal-${SCHEMA_VERSION}`;
var KEY_VALUE_STORE = "KeyValue";
var PATH_INDEX_NAME = "pathIndex";
var SCHEMA = {
  __version: SCHEMA_VERSION,
  [KEY_VALUE_STORE]: {
    __options: { keyPath: "key" },
    __indexes: [{ name: PATH_INDEX_NAME, keypath: "path", options: { unique: false, multiEntry: false } }]
  }
};
function _getStoreNamesFromSchema(schema) {
  return Object.keys(schema).filter((key) => key !== "__version");
}
function _createStores(db, schema) {
  const storeNames = _getStoreNamesFromSchema(schema);
  storeNames.forEach((storeName) => {
    const storeSchema = schema[storeName];
    const store = db.createObjectStore(storeName, storeSchema.__options);
    const indexes = storeSchema.__indexes ?? [];
    indexes.forEach((indexConfig) => {
      store.createIndex(indexConfig.name, indexConfig.keypath, indexConfig.options);
    });
  });
}
async function _open(name, schema) {
  const version = schema.__version;
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(name, version);
    request.onerror = (event) => reject(`Failed to open "${name}" database with error code ${event.target.errorCode}.`);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (schema.__version === 1) {
        _createStores(db, schema);
      } else {
        throw new Error("Schema migration is unimplemented.");
      }
    };
    request.onsuccess = (event) => {
      const db = event.target.result;
      db.onerror = (event2) => {
        throw Error("Database error: " + event2.target.errorCode);
      };
      resolve(db);
    };
  });
}
async function _get(db, storeName, key) {
  const transaction = db.transaction(storeName);
  const objectStore = transaction.objectStore(storeName);
  const request = objectStore.get(key);
  return new Promise((resolve, reject) => {
    transaction.onerror = (event) => reject(`Failed to get from "${storeName} with error code ${event.target.errorCode}.`);
    transaction.oncomplete = (_event) => resolve(request.result);
  });
}
async function _put(db, storeName, objectToStore) {
  const transaction = db.transaction(storeName, "readwrite");
  const objectStore = transaction.objectStore(storeName);
  objectStore.put(objectToStore);
  return new Promise((resolve, reject) => {
    transaction.onerror = (event) => reject(`Failed to put to "${storeName} with error code ${event.target.errorCode}.`);
    transaction.oncomplete = () => resolve();
  });
}
async function _delete(db, storeName, key) {
  const transaction = db.transaction(storeName, "readwrite");
  const objectStore = transaction.objectStore(storeName);
  objectStore.delete(key);
  return new Promise((resolve, reject) => {
    transaction.onerror = (event) => reject(`Failed to delete record at "${key}" in "${storeName} with error code ${event.target.errorCode}.`);
    transaction.oncomplete = () => resolve();
  });
}
async function _getRecordByKey(key) {
  const db = await _open(DB_NAME, SCHEMA);
  const record = await _get(db, KEY_VALUE_STORE, key);
  if (!record) return null;
  if (record.appDataVersion === APP_DATA_VERSION) return record;
  if (record.appDataVersion > APP_DATA_VERSION) throw new Error(`Record at ${key} is v${record.appDataVersion} while app only knows versions up to v${APP_DATA_VERSION}.`);
  _upgradeRecord(record);
  _put(db, KEY_VALUE_STORE, record);
  return record;
}
async function _setFieldValue(key, fieldName, fieldValue, mimeType) {
  const db = await _open(DB_NAME, SCHEMA);
  const record = await _getRecordByKey(key) ?? { key };
  record[fieldName] = fieldValue;
  record.path = keyToPath(key);
  record.appDataVersion = APP_DATA_VERSION;
  record.mimeType = mimeType;
  record.lastModified = Date.now();
  await _put(db, KEY_VALUE_STORE, record);
}
function _upgradeRecord(record) {
  if (record.appDataVersion !== APP_DATA_VERSION) throw new Error(`Record at ${record.key} did not have upgrade handling.`);
  return record;
}
async function getText(key) {
  const record = await _getRecordByKey(key);
  return record?.text ?? null;
}
async function setText(key, text, mimeType = MIMETYPE_PLAIN_TEXT) {
  await _setFieldValue(key, "text", text, mimeType);
}
async function getAllKeysAtPath(path) {
  const db = await _open(DB_NAME, SCHEMA);
  const transaction = db.transaction(KEY_VALUE_STORE);
  const objectStore = transaction.objectStore(KEY_VALUE_STORE);
  const pathIndex = objectStore.index(PATH_INDEX_NAME);
  const request = pathIndex.getAllKeys(path);
  return new Promise((resolve, reject) => {
    request.onerror = (event) => reject(`Failed to get all keys from "${path}" path with error code ${event.target.errorCode}.`);
    request.onsuccess = () => resolve(request.result);
  });
}
async function deleteByKey(key) {
  const db = await _open(DB_NAME, SCHEMA);
  await _delete(db, KEY_VALUE_STORE, key);
}
function _categoryNameToPath(categoryName) {
  return `/settings/${categoryName}.json`;
}
async function getCategorySettings(categoryName) {
  const path = _categoryNameToPath(categoryName);
  const settingsJson = await getText(path);
  if (!settingsJson) return null;
  const settings = JSON.parse(settingsJson);
  if (!isSettingValuesFormat(settings)) {
    console.error(`Settings for category "${categoryName}" are invalid.`);
    return null;
  }
  return Object.keys(settings).length > 0 ? settings : null;
}
async function setCategorySettings(categoryName, settingValues) {
  const path = _categoryNameToPath(categoryName);
  const settingsJson = JSON.stringify(settingValues);
  await setText(path, settingsJson);
}
function isSupportedModelFormat(maybeModel) {
  if (!maybeModel || typeof maybeModel !== "object") return false;
  if (typeof maybeModel.id !== "string") return false;
  if (typeof maybeModel.appBehaviorSummary !== "string") return false;
  if (maybeModel.beta !== void 0 && typeof maybeModel.beta !== "boolean") return false;
  return true;
}
function duplicateSupportedModel(model) {
  return { ...model };
}
var SettingType = ((SettingType2) => {
  SettingType2[SettingType2["BOOLEAN_TOGGLE"] = 1] = "BOOLEAN_TOGGLE";
  SettingType2[SettingType2["NUMERIC"] = 2] = "NUMERIC";
  SettingType2[SettingType2["SUPPORTED_MODEL"] = 3] = "SUPPORTED_MODEL";
  SettingType2[SettingType2["TEXT"] = 0] = "TEXT";
  return SettingType2;
})(SettingType || {});
function duplicateSupportedModelSetting(setting) {
  return {
    ...setting,
    models: setting.models.map(duplicateSupportedModel)
  };
}
function assertNonNullable(x, message = "Value is unexpectedly undefined/null.") {
  if (x === void 0 || x === null) throw new Error(message);
}
function assertTruthy(condition, message = "Condition is unexpectedly falsy.") {
  if (!condition) throw new Error(message);
}
function assert(condition, message = "Assertion failed.") {
  if (!condition) throw new Error(message);
}
function botch(message = "Botched!") {
  throw new Error(message);
}
function duplicateBooleanToggleSetting(setting) {
  return { ...setting };
}
function duplicateNumericSetting(setting) {
  return { ...setting };
}
function duplicateTextSetting(setting) {
  return { ...setting };
}
function duplicateSetting(setting) {
  switch (setting.type) {
    case SettingType.BOOLEAN_TOGGLE:
      return duplicateBooleanToggleSetting(setting);
    case SettingType.NUMERIC:
      return duplicateNumericSetting(setting);
    case SettingType.SUPPORTED_MODEL:
      return duplicateSupportedModelSetting(setting);
    case SettingType.TEXT:
      return duplicateTextSetting(setting);
    /* v8 ignore start */
    default:
      botch();
  }
}
function duplicateDisablementRule(rule) {
  return { ...rule };
}
function duplicateSettingCategory(category) {
  return {
    name: category.name,
    id: category.id,
    description: category.description,
    headings: category.headings ? category.headings.map(duplicateHeading) : void 0,
    settings: category.settings.map(duplicateSetting),
    disablementRules: category.disablementRules ? category.disablementRules.map(duplicateDisablementRule) : void 0
  };
}
function _findMatchingSettingIndex(settings, settingId) {
  for (let i = 0; i < settings.length; i++) {
    if (settings[i].id === settingId) return i;
  }
  return -1;
}
function mergeSettingValuesIntoSettings(settings, settingValues) {
  const nextSettings = settings.map(duplicateSetting);
  Object.keys(settingValues).forEach((settingId) => {
    const defaultSettingIndex = _findMatchingSettingIndex(nextSettings, settingId);
    if (defaultSettingIndex !== -1) nextSettings[defaultSettingIndex].value = settingValues[settingId];
  });
  return nextSettings;
}
function mergeSettingValuesIntoCategory(category, settingValues) {
  const nextCategory = duplicateSettingCategory(category);
  nextCategory.settings = mergeSettingValuesIntoSettings(nextCategory.settings, settingValues);
  return nextCategory;
}
function settingsToSettingValues(settings) {
  const settingValues = {};
  settings.forEach((setting) => {
    if (setting.id) {
      settingValues[setting.id] = setting.value;
    }
  });
  return settingValues;
}
function windowLocationPathname() {
  return window.location.pathname;
}
function browserClientRect() {
  return document.documentElement.getBoundingClientRect();
}
function _isSizePart(part) {
  if (part.toLowerCase() === "mini") return true;
  const lastChar = part[part.length - 1];
  if ("BbMm".indexOf(lastChar) === -1 || part.length < 2) return false;
  for (let i = 0; i < part.length - 1; ++i) {
    const c = part[i];
    if ("0123456789.".indexOf(c) === -1) return false;
  }
  return true;
}
function _isDistillPart(part) {
  return part.toLowerCase() === "distill";
}
function _hasMixedCase(part) {
  const lower = part.toLowerCase(), upper = part.toUpperCase();
  return part !== lower && part !== upper;
}
function _toInitialCap(part) {
  assert(part.length > 0);
  return part[0].toUpperCase() + part.slice(1).toLowerCase();
}
function _normalizeFamilyName(part) {
  if (_hasMixedCase(part)) return part;
  return _toInitialCap(part);
}
function _normalizeSize(part) {
  if (part.toLowerCase() === "mini") return "Mini";
  return part.toUpperCase();
}
function nicknameModelId(modelId, otherNicknames = []) {
  let familyName = "", size = "", distillName = "";
  const parts = modelId.split("-");
  familyName = _normalizeFamilyName(parts[0].trim());
  for (let partI = 1; partI < parts.length; ++partI) {
    const part = parts[partI].trim();
    if (_isSizePart(part)) size = _normalizeSize(part);
    if (_isDistillPart(part) && partI < parts.length - 1) distillName = _normalizeFamilyName(parts[partI + 1].trim());
  }
  let nickname = distillName.length ? `${distillName} < ${familyName} ${size}`.trim() : `${familyName} ${size}`.trim();
  const nicknameNumber = otherNicknames.filter((n) => n === nickname || n.startsWith(`${nickname} #`)).length;
  if (nicknameNumber > 0) nickname += ` #${nicknameNumber + 1}`;
  return nickname;
}
function createMovingAverage(seriesMax) {
  return { series: [], seriesMax, lastAverage: 0 };
}
function updateMovingAverage(nextValue, movingAverageData) {
  const { series, seriesMax } = movingAverageData;
  series.push(nextValue);
  if (series.length > seriesMax) series.shift();
  const sum = series.reduce((acc, val) => acc + val, 0);
  movingAverageData.lastAverage = sum / series.length;
  return movingAverageData.lastAverage;
}
var ModelDeviceProblemType = ((ModelDeviceProblemType2) => {
  ModelDeviceProblemType2[ModelDeviceProblemType2["INSUFFICIENT_VRAM"] = 0] = "INSUFFICIENT_VRAM";
  ModelDeviceProblemType2[ModelDeviceProblemType2["INSUFFICIENT_STORAGE"] = 1] = "INSUFFICIENT_STORAGE";
  ModelDeviceProblemType2[ModelDeviceProblemType2["BAD_LOAD_SUCCESS_HISTORY"] = 2] = "BAD_LOAD_SUCCESS_HISTORY";
  ModelDeviceProblemType2[ModelDeviceProblemType2["BAD_PERFORMANCE_HISTORY"] = 3] = "BAD_PERFORMANCE_HISTORY";
  ModelDeviceProblemType2[ModelDeviceProblemType2["DEVELOPER_MODE"] = 4] = "DEVELOPER_MODE";
  ModelDeviceProblemType2[ModelDeviceProblemType2["WEBGPU_NOT_AVAILABLE"] = 5] = "WEBGPU_NOT_AVAILABLE";
  ModelDeviceProblemType2[ModelDeviceProblemType2["BETA"] = 6] = "BETA";
  return ModelDeviceProblemType2;
})(ModelDeviceProblemType || {});
function hasWebGpuSupport() {
  if (!globalThis.navigator || !globalThis.navigator.gpu) return false;
  return !!globalThis.navigator.gpu;
}
function hasStorageSupport() {
  if (!globalThis.navigator || !globalThis.navigator.gpu) return false;
  return !!globalThis.navigator.storage && !!globalThis.navigator.storage.estimate;
}
async function estimateAvailableStorage() {
  if (!hasStorageSupport()) return 0;
  const estimate = await navigator.storage.estimate();
  if (!estimate || estimate.quota === void 0 || estimate.usage === void 0) return 0;
  const quota = estimate.quota;
  const usage = estimate.usage;
  return quota - usage;
}
function isMovingAverageDataFormat(obj) {
  return obj && Array.isArray(obj.series) && typeof obj.seriesMax === "number" && typeof obj.lastAverage === "number" && obj.series.every((val) => typeof val === "number");
}
function isModelDeviceHistoryFormat(obj) {
  return obj && isMovingAverageDataFormat(obj.loadSuccessRate) && isMovingAverageDataFormat(obj.loadTime) && isMovingAverageDataFormat(obj.inputCharsPerSec) && isMovingAverageDataFormat(obj.outputCharsPerSec);
}
var LOAD_SUCCESS_RATE_SAMPLE_COUNT = 4;
var LOAD_TIME_SAMPLE_COUNT = 4;
var INPUT_TOKENS_SAMPLE_COUNT = 20;
var OUTPUT_TOKENS_SAMPLE_COUNT = 20;
function _modelIdToKey(modelId) {
  return `/deviceHistory/models/${modelId}.json`;
}
function _createModelDeviceHistory() {
  return {
    loadSuccessRate: createMovingAverage(LOAD_SUCCESS_RATE_SAMPLE_COUNT),
    loadTime: createMovingAverage(LOAD_TIME_SAMPLE_COUNT),
    inputCharsPerSec: createMovingAverage(INPUT_TOKENS_SAMPLE_COUNT),
    outputCharsPerSec: createMovingAverage(OUTPUT_TOKENS_SAMPLE_COUNT)
  };
}
async function getModelDeviceHistory(modelId) {
  const key = _modelIdToKey(modelId);
  const json = await getText(key);
  if (!json) return _createModelDeviceHistory();
  try {
    const history = JSON.parse(json);
    if (!isModelDeviceHistoryFormat(history)) {
      console.error(`Model device history for model ${modelId} is not in the expected format. Reinitializing history.`);
      return _createModelDeviceHistory();
    }
    return history;
  } catch (e) {
    console.error(`Failed to parse model device history for model ${modelId}:`, e);
    return _createModelDeviceHistory();
  }
}
async function setModelDeviceHistory(modelId, history) {
  const key = _modelIdToKey(modelId);
  const json = JSON.stringify(history);
  await setText(key, json);
}
function isIpAddress(hostName) {
  return hostName.match(/^\d+\.\d+\.\d+\.\d+$/g) !== null;
}
function isServingLocally() {
  const hostName = window.location.hostname;
  return hostName === "localhost" || isIpAddress(hostName);
}
var theModelList = {
  "Llama-3.2-1B-Instruct-q4f32_1-MLC": { "modelId": "Llama-3.2-1B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1128.82 },
  "Llama-3.2-1B-Instruct-q4f16_1-MLC": { "modelId": "Llama-3.2-1B-Instruct-q4f16_1-MLC", "vramRequiredMb": 879.04 },
  "Llama-3.2-1B-Instruct-q0f32-MLC": { "modelId": "Llama-3.2-1B-Instruct-q0f32-MLC", "vramRequiredMb": 5106.26 },
  "Llama-3.2-1B-Instruct-q0f16-MLC": { "modelId": "Llama-3.2-1B-Instruct-q0f16-MLC", "vramRequiredMb": 2573.13 },
  "Llama-3.2-3B-Instruct-q4f32_1-MLC": { "modelId": "Llama-3.2-3B-Instruct-q4f32_1-MLC", "vramRequiredMb": 2951.51 },
  "Llama-3.2-3B-Instruct-q4f16_1-MLC": { "modelId": "Llama-3.2-3B-Instruct-q4f16_1-MLC", "vramRequiredMb": 2263.69 },
  "Llama-3.1-8B-Instruct-q4f32_1-MLC-1k": { "modelId": "Llama-3.1-8B-Instruct-q4f32_1-MLC-1k", "vramRequiredMb": 5295.7 },
  "Llama-3.1-8B-Instruct-q4f16_1-MLC-1k": { "modelId": "Llama-3.1-8B-Instruct-q4f16_1-MLC-1k", "vramRequiredMb": 4598.34 },
  "Llama-3.1-8B-Instruct-q4f32_1-MLC": { "modelId": "Llama-3.1-8B-Instruct-q4f32_1-MLC", "vramRequiredMb": 6101.01 },
  "Llama-3.1-8B-Instruct-q4f16_1-MLC": { "modelId": "Llama-3.1-8B-Instruct-q4f16_1-MLC", "vramRequiredMb": 5001 },
  "DeepSeek-R1-Distill-Qwen-1.5B-q4f16_1-MLC": { "modelId": "DeepSeek-R1-Distill-Qwen-1.5B-q4f16_1-MLC", "vramRequiredMb": 1629.75 },
  "DeepSeek-R1-Distill-Qwen-1.5B-q4f32_1-MLC": { "modelId": "DeepSeek-R1-Distill-Qwen-1.5B-q4f32_1-MLC", "vramRequiredMb": 1888.97 },
  "DeepSeek-R1-Distill-Qwen-7B-q4f16_1-MLC": { "modelId": "DeepSeek-R1-Distill-Qwen-7B-q4f16_1-MLC", "vramRequiredMb": 5106.67 },
  "DeepSeek-R1-Distill-Qwen-7B-q4f32_1-MLC": { "modelId": "DeepSeek-R1-Distill-Qwen-7B-q4f32_1-MLC", "vramRequiredMb": 5900.09 },
  "DeepSeek-R1-Distill-Llama-8B-q4f32_1-MLC": { "modelId": "DeepSeek-R1-Distill-Llama-8B-q4f32_1-MLC", "vramRequiredMb": 6101.01 },
  "DeepSeek-R1-Distill-Llama-8B-q4f16_1-MLC": { "modelId": "DeepSeek-R1-Distill-Llama-8B-q4f16_1-MLC", "vramRequiredMb": 5001 },
  "Hermes-2-Theta-Llama-3-8B-q4f16_1-MLC": { "modelId": "Hermes-2-Theta-Llama-3-8B-q4f16_1-MLC", "vramRequiredMb": 4976.13 },
  "Hermes-2-Theta-Llama-3-8B-q4f32_1-MLC": { "modelId": "Hermes-2-Theta-Llama-3-8B-q4f32_1-MLC", "vramRequiredMb": 6051.27 },
  "Hermes-2-Pro-Llama-3-8B-q4f16_1-MLC": { "modelId": "Hermes-2-Pro-Llama-3-8B-q4f16_1-MLC", "vramRequiredMb": 4976.13 },
  "Hermes-2-Pro-Llama-3-8B-q4f32_1-MLC": { "modelId": "Hermes-2-Pro-Llama-3-8B-q4f32_1-MLC", "vramRequiredMb": 6051.27 },
  "Hermes-3-Llama-3.2-3B-q4f32_1-MLC": { "modelId": "Hermes-3-Llama-3.2-3B-q4f32_1-MLC", "vramRequiredMb": 2951.51 },
  "Hermes-3-Llama-3.2-3B-q4f16_1-MLC": { "modelId": "Hermes-3-Llama-3.2-3B-q4f16_1-MLC", "vramRequiredMb": 2263.69 },
  "Hermes-3-Llama-3.1-8B-q4f32_1-MLC": { "modelId": "Hermes-3-Llama-3.1-8B-q4f32_1-MLC", "vramRequiredMb": 5779.27 },
  "Hermes-3-Llama-3.1-8B-q4f16_1-MLC": { "modelId": "Hermes-3-Llama-3.1-8B-q4f16_1-MLC", "vramRequiredMb": 4876.13 },
  "Hermes-2-Pro-Mistral-7B-q4f16_1-MLC": { "modelId": "Hermes-2-Pro-Mistral-7B-q4f16_1-MLC", "vramRequiredMb": 4033.28 },
  "Phi-3.5-mini-instruct-q4f16_1-MLC": { "modelId": "Phi-3.5-mini-instruct-q4f16_1-MLC", "vramRequiredMb": 3672.07 },
  "Phi-3.5-mini-instruct-q4f32_1-MLC": { "modelId": "Phi-3.5-mini-instruct-q4f32_1-MLC", "vramRequiredMb": 5483.12 },
  "Phi-3.5-mini-instruct-q4f16_1-MLC-1k": { "modelId": "Phi-3.5-mini-instruct-q4f16_1-MLC-1k", "vramRequiredMb": 2520.07 },
  "Phi-3.5-mini-instruct-q4f32_1-MLC-1k": { "modelId": "Phi-3.5-mini-instruct-q4f32_1-MLC-1k", "vramRequiredMb": 3179.12 },
  "Phi-3.5-vision-instruct-q4f16_1-MLC": { "modelId": "Phi-3.5-vision-instruct-q4f16_1-MLC", "vramRequiredMb": 3952.18 },
  "Phi-3.5-vision-instruct-q4f32_1-MLC": { "modelId": "Phi-3.5-vision-instruct-q4f32_1-MLC", "vramRequiredMb": 5879.84 },
  "Mistral-7B-Instruct-v0.3-q4f16_1-MLC": { "modelId": "Mistral-7B-Instruct-v0.3-q4f16_1-MLC", "vramRequiredMb": 4573.39 },
  "Mistral-7B-Instruct-v0.3-q4f32_1-MLC": { "modelId": "Mistral-7B-Instruct-v0.3-q4f32_1-MLC", "vramRequiredMb": 5619.27 },
  "Mistral-7B-Instruct-v0.2-q4f16_1-MLC": { "modelId": "Mistral-7B-Instruct-v0.2-q4f16_1-MLC", "vramRequiredMb": 4573.39 },
  "OpenHermes-2.5-Mistral-7B-q4f16_1-MLC": { "modelId": "OpenHermes-2.5-Mistral-7B-q4f16_1-MLC", "vramRequiredMb": 4573.39 },
  "NeuralHermes-2.5-Mistral-7B-q4f16_1-MLC": { "modelId": "NeuralHermes-2.5-Mistral-7B-q4f16_1-MLC", "vramRequiredMb": 4573.39 },
  "WizardMath-7B-V1.1-q4f16_1-MLC": { "modelId": "WizardMath-7B-V1.1-q4f16_1-MLC", "vramRequiredMb": 4573.39 },
  "SmolLM2-1.7B-Instruct-q4f16_1-MLC": { "modelId": "SmolLM2-1.7B-Instruct-q4f16_1-MLC", "vramRequiredMb": 1774.19 },
  "SmolLM2-1.7B-Instruct-q4f32_1-MLC": { "modelId": "SmolLM2-1.7B-Instruct-q4f32_1-MLC", "vramRequiredMb": 2692.38 },
  "SmolLM2-360M-Instruct-q0f16-MLC": { "modelId": "SmolLM2-360M-Instruct-q0f16-MLC", "vramRequiredMb": 871.99 },
  "SmolLM2-360M-Instruct-q0f32-MLC": { "modelId": "SmolLM2-360M-Instruct-q0f32-MLC", "vramRequiredMb": 1743.99 },
  "SmolLM2-360M-Instruct-q4f16_1-MLC": { "modelId": "SmolLM2-360M-Instruct-q4f16_1-MLC", "vramRequiredMb": 376.06 },
  "SmolLM2-360M-Instruct-q4f32_1-MLC": { "modelId": "SmolLM2-360M-Instruct-q4f32_1-MLC", "vramRequiredMb": 579.61 },
  "SmolLM2-135M-Instruct-q0f16-MLC": { "modelId": "SmolLM2-135M-Instruct-q0f16-MLC", "vramRequiredMb": 359.69 },
  "SmolLM2-135M-Instruct-q0f32-MLC": { "modelId": "SmolLM2-135M-Instruct-q0f32-MLC", "vramRequiredMb": 719.38 },
  "gemma-2-2b-it-q4f16_1-MLC": { "modelId": "gemma-2-2b-it-q4f16_1-MLC", "vramRequiredMb": 1895.3 },
  "gemma-2-2b-it-q4f32_1-MLC": { "modelId": "gemma-2-2b-it-q4f32_1-MLC", "vramRequiredMb": 2508.75 },
  "gemma-2-2b-it-q4f16_1-MLC-1k": { "modelId": "gemma-2-2b-it-q4f16_1-MLC-1k", "vramRequiredMb": 1583.3 },
  "gemma-2-2b-it-q4f32_1-MLC-1k": { "modelId": "gemma-2-2b-it-q4f32_1-MLC-1k", "vramRequiredMb": 1884.75 },
  "gemma-2-9b-it-q4f16_1-MLC": { "modelId": "gemma-2-9b-it-q4f16_1-MLC", "vramRequiredMb": 6422.01 },
  "gemma-2-9b-it-q4f32_1-MLC": { "modelId": "gemma-2-9b-it-q4f32_1-MLC", "vramRequiredMb": 8383.33 },
  "gemma-2-2b-jpn-it-q4f16_1-MLC": { "modelId": "gemma-2-2b-jpn-it-q4f16_1-MLC", "vramRequiredMb": 1895.3 },
  "gemma-2-2b-jpn-it-q4f32_1-MLC": { "modelId": "gemma-2-2b-jpn-it-q4f32_1-MLC", "vramRequiredMb": 2508.75 },
  "Qwen3-0.6B-q4f16_1-MLC": { "modelId": "Qwen3-0.6B-q4f16_1-MLC", "vramRequiredMb": 1403.34 },
  "Qwen3-0.6B-q4f32_1-MLC": { "modelId": "Qwen3-0.6B-q4f32_1-MLC", "vramRequiredMb": 1924.98 },
  "Qwen3-0.6B-q0f16-MLC": { "modelId": "Qwen3-0.6B-q0f16-MLC", "vramRequiredMb": 2220.38 },
  "Qwen3-0.6B-q0f32-MLC": { "modelId": "Qwen3-0.6B-q0f32-MLC", "vramRequiredMb": 3843.25 },
  "Qwen3-1.7B-q4f16_1-MLC": { "modelId": "Qwen3-1.7B-q4f16_1-MLC", "vramRequiredMb": 2036.66 },
  "Qwen3-1.7B-q4f32_1-MLC": { "modelId": "Qwen3-1.7B-q4f32_1-MLC", "vramRequiredMb": 2635.44 },
  "Qwen3-4B-q4f16_1-MLC": { "modelId": "Qwen3-4B-q4f16_1-MLC", "vramRequiredMb": 3431.59 },
  "Qwen3-4B-q4f32_1-MLC": { "modelId": "Qwen3-4B-q4f32_1-MLC", "vramRequiredMb": 4327.71 },
  "Qwen3-8B-q4f16_1-MLC": { "modelId": "Qwen3-8B-q4f16_1-MLC", "vramRequiredMb": 5695.78 },
  "Qwen3-8B-q4f32_1-MLC": { "modelId": "Qwen3-8B-q4f32_1-MLC", "vramRequiredMb": 6852.55 },
  "Qwen2.5-0.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-0.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 944.62 },
  "Qwen2.5-0.5B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-0.5B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1060.2 },
  "Qwen2.5-0.5B-Instruct-q0f16-MLC": { "modelId": "Qwen2.5-0.5B-Instruct-q0f16-MLC", "vramRequiredMb": 1624.12 },
  "Qwen2.5-0.5B-Instruct-q0f32-MLC": { "modelId": "Qwen2.5-0.5B-Instruct-q0f32-MLC", "vramRequiredMb": 2654.75 },
  "Qwen2.5-1.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-1.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 1629.75 },
  "Qwen2.5-1.5B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-1.5B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1888.97 },
  "Qwen2.5-3B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-3B-Instruct-q4f16_1-MLC", "vramRequiredMb": 2504.76 },
  "Qwen2.5-3B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-3B-Instruct-q4f32_1-MLC", "vramRequiredMb": 2893.64 },
  "Qwen2.5-7B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-7B-Instruct-q4f16_1-MLC", "vramRequiredMb": 5106.67 },
  "Qwen2.5-7B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-7B-Instruct-q4f32_1-MLC", "vramRequiredMb": 5900.09 },
  "Qwen2.5-Coder-0.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-Coder-0.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 944.62 },
  "Qwen2.5-Coder-0.5B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-Coder-0.5B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1060.2 },
  "Qwen2.5-Coder-0.5B-Instruct-q0f16-MLC": { "modelId": "Qwen2.5-Coder-0.5B-Instruct-q0f16-MLC", "vramRequiredMb": 1624.12 },
  "Qwen2.5-Coder-0.5B-Instruct-q0f32-MLC": { "modelId": "Qwen2.5-Coder-0.5B-Instruct-q0f32-MLC", "vramRequiredMb": 2654.75 },
  "Qwen2.5-Coder-1.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-Coder-1.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 1629.75 },
  "Qwen2.5-Coder-1.5B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-Coder-1.5B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1888.97 },
  "Qwen2.5-Coder-3B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-Coder-3B-Instruct-q4f16_1-MLC", "vramRequiredMb": 2504.76 },
  "Qwen2.5-Coder-3B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-Coder-3B-Instruct-q4f32_1-MLC", "vramRequiredMb": 2893.64 },
  "Qwen2.5-Coder-7B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-Coder-7B-Instruct-q4f16_1-MLC", "vramRequiredMb": 5106.67 },
  "Qwen2.5-Coder-7B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-Coder-7B-Instruct-q4f32_1-MLC", "vramRequiredMb": 5900.09 },
  "Qwen2.5-Math-1.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2.5-Math-1.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 1629.75 },
  "Qwen2.5-Math-1.5B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2.5-Math-1.5B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1888.97 },
  "stablelm-2-zephyr-1_6b-q4f16_1-MLC": { "modelId": "stablelm-2-zephyr-1_6b-q4f16_1-MLC", "vramRequiredMb": 2087.66 },
  "stablelm-2-zephyr-1_6b-q4f32_1-MLC": { "modelId": "stablelm-2-zephyr-1_6b-q4f32_1-MLC", "vramRequiredMb": 2999.33 },
  "stablelm-2-zephyr-1_6b-q4f16_1-MLC-1k": { "modelId": "stablelm-2-zephyr-1_6b-q4f16_1-MLC-1k", "vramRequiredMb": 1511.66 },
  "stablelm-2-zephyr-1_6b-q4f32_1-MLC-1k": { "modelId": "stablelm-2-zephyr-1_6b-q4f32_1-MLC-1k", "vramRequiredMb": 1847.33 },
  "RedPajama-INCITE-Chat-3B-v1-q4f16_1-MLC": { "modelId": "RedPajama-INCITE-Chat-3B-v1-q4f16_1-MLC", "vramRequiredMb": 2972.09 },
  "RedPajama-INCITE-Chat-3B-v1-q4f32_1-MLC": { "modelId": "RedPajama-INCITE-Chat-3B-v1-q4f32_1-MLC", "vramRequiredMb": 3928.09 },
  "RedPajama-INCITE-Chat-3B-v1-q4f16_1-MLC-1k": { "modelId": "RedPajama-INCITE-Chat-3B-v1-q4f16_1-MLC-1k", "vramRequiredMb": 2041.09 },
  "RedPajama-INCITE-Chat-3B-v1-q4f32_1-MLC-1k": { "modelId": "RedPajama-INCITE-Chat-3B-v1-q4f32_1-MLC-1k", "vramRequiredMb": 2558.09 },
  "TinyLlama-1.1B-Chat-v1.0-q4f16_1-MLC": { "modelId": "TinyLlama-1.1B-Chat-v1.0-q4f16_1-MLC", "vramRequiredMb": 697.24 },
  "TinyLlama-1.1B-Chat-v1.0-q4f32_1-MLC": { "modelId": "TinyLlama-1.1B-Chat-v1.0-q4f32_1-MLC", "vramRequiredMb": 839.98 },
  "TinyLlama-1.1B-Chat-v1.0-q4f16_1-MLC-1k": { "modelId": "TinyLlama-1.1B-Chat-v1.0-q4f16_1-MLC-1k", "vramRequiredMb": 675.24 },
  "TinyLlama-1.1B-Chat-v1.0-q4f32_1-MLC-1k": { "modelId": "TinyLlama-1.1B-Chat-v1.0-q4f32_1-MLC-1k", "vramRequiredMb": 795.98 },
  "Llama-3.1-70B-Instruct-q3f16_1-MLC": { "modelId": "Llama-3.1-70B-Instruct-q3f16_1-MLC", "vramRequiredMb": 31153.13 },
  "Qwen2-0.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2-0.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 944.62 },
  "Qwen2-0.5B-Instruct-q0f16-MLC": { "modelId": "Qwen2-0.5B-Instruct-q0f16-MLC", "vramRequiredMb": 1624.12 },
  "Qwen2-0.5B-Instruct-q0f32-MLC": { "modelId": "Qwen2-0.5B-Instruct-q0f32-MLC", "vramRequiredMb": 2654.75 },
  "Qwen2-1.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2-1.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 1629.75 },
  "Qwen2-1.5B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2-1.5B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1888.97 },
  "Qwen2-7B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2-7B-Instruct-q4f16_1-MLC", "vramRequiredMb": 5106.67 },
  "Qwen2-7B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2-7B-Instruct-q4f32_1-MLC", "vramRequiredMb": 5900.09 },
  "Qwen2-Math-1.5B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2-Math-1.5B-Instruct-q4f16_1-MLC", "vramRequiredMb": 1629.75 },
  "Qwen2-Math-1.5B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2-Math-1.5B-Instruct-q4f32_1-MLC", "vramRequiredMb": 1888.97 },
  "Qwen2-Math-7B-Instruct-q4f16_1-MLC": { "modelId": "Qwen2-Math-7B-Instruct-q4f16_1-MLC", "vramRequiredMb": 5106.67 },
  "Qwen2-Math-7B-Instruct-q4f32_1-MLC": { "modelId": "Qwen2-Math-7B-Instruct-q4f32_1-MLC", "vramRequiredMb": 5900.09 },
  "Llama-3-8B-Instruct-q4f32_1-MLC-1k": { "modelId": "Llama-3-8B-Instruct-q4f32_1-MLC-1k", "vramRequiredMb": 5295.7 },
  "Llama-3-8B-Instruct-q4f16_1-MLC-1k": { "modelId": "Llama-3-8B-Instruct-q4f16_1-MLC-1k", "vramRequiredMb": 4598.34 },
  "Llama-3-8B-Instruct-q4f32_1-MLC": { "modelId": "Llama-3-8B-Instruct-q4f32_1-MLC", "vramRequiredMb": 6101.01 },
  "Llama-3-8B-Instruct-q4f16_1-MLC": { "modelId": "Llama-3-8B-Instruct-q4f16_1-MLC", "vramRequiredMb": 5001 },
  "Llama-3-70B-Instruct-q3f16_1-MLC": { "modelId": "Llama-3-70B-Instruct-q3f16_1-MLC", "vramRequiredMb": 31153.13 },
  "Phi-3-mini-4k-instruct-q4f16_1-MLC": { "modelId": "Phi-3-mini-4k-instruct-q4f16_1-MLC", "vramRequiredMb": 3672.07 },
  "Phi-3-mini-4k-instruct-q4f32_1-MLC": { "modelId": "Phi-3-mini-4k-instruct-q4f32_1-MLC", "vramRequiredMb": 5483.12 },
  "Phi-3-mini-4k-instruct-q4f16_1-MLC-1k": { "modelId": "Phi-3-mini-4k-instruct-q4f16_1-MLC-1k", "vramRequiredMb": 2520.07 },
  "Phi-3-mini-4k-instruct-q4f32_1-MLC-1k": { "modelId": "Phi-3-mini-4k-instruct-q4f32_1-MLC-1k", "vramRequiredMb": 3179.12 },
  "Llama-2-7b-chat-hf-q4f32_1-MLC-1k": { "modelId": "Llama-2-7b-chat-hf-q4f32_1-MLC-1k", "vramRequiredMb": 5284.01 },
  "Llama-2-7b-chat-hf-q4f16_1-MLC-1k": { "modelId": "Llama-2-7b-chat-hf-q4f16_1-MLC-1k", "vramRequiredMb": 4618.52 },
  "Llama-2-7b-chat-hf-q4f32_1-MLC": { "modelId": "Llama-2-7b-chat-hf-q4f32_1-MLC", "vramRequiredMb": 9109.03 },
  "Llama-2-7b-chat-hf-q4f16_1-MLC": { "modelId": "Llama-2-7b-chat-hf-q4f16_1-MLC", "vramRequiredMb": 6749.02 },
  "Llama-2-13b-chat-hf-q4f16_1-MLC": { "modelId": "Llama-2-13b-chat-hf-q4f16_1-MLC", "vramRequiredMb": 11814.09 },
  "gemma-2b-it-q4f16_1-MLC": { "modelId": "gemma-2b-it-q4f16_1-MLC", "vramRequiredMb": 1476.52 },
  "gemma-2b-it-q4f32_1-MLC": { "modelId": "gemma-2b-it-q4f32_1-MLC", "vramRequiredMb": 1750.66 },
  "gemma-2b-it-q4f16_1-MLC-1k": { "modelId": "gemma-2b-it-q4f16_1-MLC-1k", "vramRequiredMb": 1476.52 },
  "gemma-2b-it-q4f32_1-MLC-1k": { "modelId": "gemma-2b-it-q4f32_1-MLC-1k", "vramRequiredMb": 1750.66 },
  "phi-2-q4f16_1-MLC": { "modelId": "phi-2-q4f16_1-MLC", "vramRequiredMb": 3053.97 },
  "phi-2-q4f32_1-MLC": { "modelId": "phi-2-q4f32_1-MLC", "vramRequiredMb": 4032.48 },
  "phi-2-q4f16_1-MLC-1k": { "modelId": "phi-2-q4f16_1-MLC-1k", "vramRequiredMb": 2131.97 },
  "phi-2-q4f32_1-MLC-1k": { "modelId": "phi-2-q4f32_1-MLC-1k", "vramRequiredMb": 2740.48 },
  "phi-1_5-q4f16_1-MLC": { "modelId": "phi-1_5-q4f16_1-MLC", "vramRequiredMb": 1210.09 },
  "phi-1_5-q4f32_1-MLC": { "modelId": "phi-1_5-q4f32_1-MLC", "vramRequiredMb": 1682.09 },
  "phi-1_5-q4f16_1-MLC-1k": { "modelId": "phi-1_5-q4f16_1-MLC-1k", "vramRequiredMb": 1210.09 },
  "phi-1_5-q4f32_1-MLC-1k": { "modelId": "phi-1_5-q4f32_1-MLC-1k", "vramRequiredMb": 1682.09 },
  "TinyLlama-1.1B-Chat-v0.4-q4f16_1-MLC": { "modelId": "TinyLlama-1.1B-Chat-v0.4-q4f16_1-MLC", "vramRequiredMb": 697.24 },
  "TinyLlama-1.1B-Chat-v0.4-q4f32_1-MLC": { "modelId": "TinyLlama-1.1B-Chat-v0.4-q4f32_1-MLC", "vramRequiredMb": 839.98 },
  "TinyLlama-1.1B-Chat-v0.4-q4f16_1-MLC-1k": { "modelId": "TinyLlama-1.1B-Chat-v0.4-q4f16_1-MLC-1k", "vramRequiredMb": 675.24 },
  "TinyLlama-1.1B-Chat-v0.4-q4f32_1-MLC-1k": { "modelId": "TinyLlama-1.1B-Chat-v0.4-q4f32_1-MLC-1k", "vramRequiredMb": 795.98 },
  "snowflake-arctic-embed-m-q0f32-MLC-b32": { "modelId": "snowflake-arctic-embed-m-q0f32-MLC-b32", "vramRequiredMb": 1407.51 },
  "snowflake-arctic-embed-m-q0f32-MLC-b4": { "modelId": "snowflake-arctic-embed-m-q0f32-MLC-b4", "vramRequiredMb": 539.4 },
  "snowflake-arctic-embed-s-q0f32-MLC-b32": { "modelId": "snowflake-arctic-embed-s-q0f32-MLC-b32", "vramRequiredMb": 1022.82 },
  "snowflake-arctic-embed-s-q0f32-MLC-b4": { "modelId": "snowflake-arctic-embed-s-q0f32-MLC-b4", "vramRequiredMb": 238.71 }
};
var KILOBYTE = 1024;
var MEGABYTE = KILOBYTE * 1024;
var GIGABYTE = MEGABYTE * 1024;
function mbToGb(mb, decimalPlaces = 1) {
  return Math.round(mb / 1024 * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);
}
function estimateSystemMemory() {
  if (globalThis.navigator && "deviceMemory" in navigator) return navigator.deviceMemory;
  if ("memory" in performance) return Math.floor(performance.memory.jsHeapSizeLimit / GIGABYTE);
  return 0;
}
var LLM_CATEGORY_ID = "llm";
var LLM_SETTING_MAX_SIZE = "llmMaxSize";
var LLM_SETTING_AUTO_INC_MAX_SIZE = "autoIncMaxSize";
function _getDefaultMaxLlmSize() {
  const AT_LEAST_THIS_MUCH = 8;
  const availableMemory = estimateSystemMemory();
  const availableMemoryGB = Math.round(availableMemory / GIGABYTE);
  return Math.max(AT_LEAST_THIS_MUCH, availableMemoryGB);
}
function _getLlmDefaultSettings() {
  return {
    name: "LLM",
    id: LLM_CATEGORY_ID,
    description: "Settings for loading and using LLMs (Large Language Models) on this device.",
    settings: [
      { type: SettingType.NUMERIC, id: LLM_SETTING_MAX_SIZE, label: "Max LLM size (GB)", value: _getDefaultMaxLlmSize(), minValue: 1, maxValue: 256 },
      { type: SettingType.BOOLEAN_TOGGLE, id: LLM_SETTING_AUTO_INC_MAX_SIZE, label: "Auto-increase max LLM", value: true }
    ],
    headings: [
      { precedeSettingId: "llmMaxSize", description: `The max LLM size prevents attempting to load models that are unlikely to succeed and could cause system instability. The auto-increment option will increase the max LLM size if evidence is found during loading to support a larger size.` }
    ]
  };
}
async function loadLlmSettingCategory() {
  const settingValues = await getCategorySettings(LLM_CATEGORY_ID) ?? {};
  return mergeSettingValuesIntoCategory(_getLlmDefaultSettings(), settingValues);
}
async function applyLlmSettings(_settingValues) {
  return Promise.resolve();
}
async function incrementMaxLlmSizeAfterSuccessfulLoad(successfulLoadSize) {
  const llmCategory = await loadLlmSettingCategory();
  const settingValues = settingsToSettingValues(llmCategory.settings);
  const isAutoIncrementing = settingValues[LLM_SETTING_AUTO_INC_MAX_SIZE];
  if (!isAutoIncrementing) return;
  const currentMaxSize = settingValues[LLM_SETTING_MAX_SIZE];
  assertNonNullable(currentMaxSize);
  if (currentMaxSize >= successfulLoadSize) return;
  settingValues[LLM_SETTING_MAX_SIZE] = Math.ceil(successfulLoadSize);
  setCategorySettings(LLM_CATEGORY_ID, settingValues);
}
async function getMaxLlmSize() {
  const settingValues = await getCategorySettings(LLM_CATEGORY_ID);
  if (!settingValues) return _getDefaultMaxLlmSize();
  const maxSize = settingValues[LLM_SETTING_MAX_SIZE];
  if (!maxSize) return _getDefaultMaxLlmSize();
  return maxSize;
}
async function fetchAppMetadataText() {
  const baseUrl = getBaseUrl();
  const appMetaDataUrl = `${baseUrl}/app-metadata.json`;
  const response = await fetch(appMetaDataUrl);
  if (!response.ok) throw new Error(`Failed to fetch app metadata from ${appMetaDataUrl}: ${response.status} ${response.statusText}`);
  return await response.text();
}
function isAppMetaDataFormat(maybeAppMetaData) {
  if (!maybeAppMetaData || typeof maybeAppMetaData !== "object") return false;
  if (typeof maybeAppMetaData.id !== "string") return false;
  if (typeof maybeAppMetaData.name !== "string") return false;
  if (typeof maybeAppMetaData.description !== "string") return false;
  if (!Array.isArray(maybeAppMetaData.supportedModels)) return false;
  return maybeAppMetaData.supportedModels.every(isSupportedModelFormat);
}
var theAppMetaData = null;
function getAppId() {
  if (!theAppMetaData) throw new Error("App metadata not initialized yet.");
  return theAppMetaData.id;
}
function getAppName() {
  if (!theAppMetaData) throw new Error("App metadata not initialized yet.");
  return theAppMetaData.name;
}
async function initAppMetaData() {
  if (theAppMetaData) return;
  let json = "";
  try {
    json = await fetchAppMetadataText();
  } catch (e) {
    console.error("Could not fetch app-metadata.json from server. Add this file to your /public or web-serving directory to fix.");
    throw new Error(`Failed to fetch app metadata: ` + e);
  }
  let appMetaData;
  try {
    appMetaData = JSON.parse(json);
  } catch (e) {
    console.error("Server returned invalid JSON for app-metadata.json, which probably indicates a missing file. Add this file to your /public or web-serving directory to fix.");
    throw new Error(`Failed to parse app metadata JSON: ` + e);
  }
  if (!isAppMetaDataFormat(appMetaData)) throw new Error("Invalid app metadata format in app-metadata.json.");
  theAppMetaData = appMetaData;
}
async function getAppMetaData() {
  if (!theAppMetaData) await initAppMetaData();
  assertNonNullable(theAppMetaData);
  return theAppMetaData;
}
var theCurrentModelInfo = null;
function _findModelRequiredMemory(modelId) {
  const model = theModelList[modelId];
  if (!model || !model.vramRequiredMb) return 0;
  return mbToGb(model.vramRequiredMb);
}
var WEBLLM_MEMORY_TO_STORAGE_RATIO = 3;
async function _setCurrentModel(modelId) {
  if (theCurrentModelInfo?.modelId === modelId) return;
  const history = await getModelDeviceHistory(modelId);
  const requiredMemoryGb = _findModelRequiredMemory(modelId);
  if (!requiredMemoryGb) throw new Error(`Model ${modelId} not found or has no required memory.`);
  const requiredStorageGb = requiredMemoryGb * WEBLLM_MEMORY_TO_STORAGE_RATIO;
  theCurrentModelInfo = { modelId, history, requiredMemoryGb, requiredStorageGb };
}
async function _saveCurrentModel() {
  assertNonNullable(theCurrentModelInfo);
  await setModelDeviceHistory(theCurrentModelInfo.modelId, theCurrentModelInfo.history);
}
function _describeBadLoadSuccessHistory(loadSuccessRate) {
  const attemptCount = loadSuccessRate.series.length;
  const failCount = loadSuccessRate.series.filter((s) => s === 0).length;
  if (attemptCount === failCount) {
    if (attemptCount === 1) return `Your last attempt to load this model failed.`;
    if (attemptCount < loadSuccessRate.seriesMax) return `All ${attemptCount} of your attempts to load this model failed.`;
    return `All of the last ${attemptCount} attempts to load this model failed.`;
  }
  const didlastLoadFail = loadSuccessRate.series[loadSuccessRate.series.length - 1] === 0;
  const successCount = attemptCount - failCount;
  if (didlastLoadFail) return `This model loaded successfully ${successCount} in ${attemptCount} tries, with the last attempt failing.`;
  return `This model loaded successfully ${successCount} in ${attemptCount} tries.`;
}
var SLOW_INPUT_TOKEN_THRESHOLD = 6;
var SLOW_OUTPUT_TOKEN_THRESHOLD = 3;
function _areTokenRatesSlow(inputTokensPerSec, outputTokensPerSec) {
  return inputTokensPerSec.series.length > 0 && inputTokensPerSec.lastAverage < SLOW_INPUT_TOKEN_THRESHOLD || outputTokensPerSec.series.length > 0 && outputTokensPerSec.lastAverage < SLOW_OUTPUT_TOKEN_THRESHOLD;
}
function _describeBadPerformanceHistory(inputTokensPerSec, outputTokensPerSec) {
  const inputRate = inputTokensPerSec.lastAverage.toFixed(1);
  const outputRate = outputTokensPerSec.lastAverage.toFixed(1);
  const inputRateDesc = inputTokensPerSec.series.length ? `Predicted input token rate is ${inputRate} tokens/sec.` : `Can't predict input token rate.`;
  const outputRateDesc = outputTokensPerSec.series.length ? `Predicted output token rate is ${outputRate} tokens/sec.` : `Can't predict output token rate.`;
  return `This model's performance might be too slow. ${inputRateDesc} ${outputRateDesc}`;
}
function _describeInsufficientStorage(wasSuccessfulBefore, requiredStorageGb, availableStorage) {
  if (availableStorage === 0) {
    if (wasSuccessfulBefore) return `Couldn't determine how much storage is available on the device. But you had previous success loading this model.`;
    return `Couldn't determine how much storage is available on the device. There might not be enough to load the model.`;
  }
  const neededStorage = (requiredStorageGb - availableStorage).toFixed(1);
  if (wasSuccessfulBefore) return `Although you were successful loading this model previously, you might need an additional ${neededStorage} GB of free storage space on this device to load it safely.`;
  return `You probably need an additional ${neededStorage} GB of free storage space on this device to load this model safely.`;
}
function _describeInsufficientMemory(wasSuccessfulBefore, requiredMemoryGb, maxLlmSize) {
  if (maxLlmSize == 0) {
    if (wasSuccessfulBefore) return `Couldn't determine how much memory is available on the device. But you did have previous success loading this model.`;
    return `Couldn't determine how much memory is available on the device. There might not be enough to load the model.`;
  }
  if (wasSuccessfulBefore) return `It looks like you may not have enough video memory. But you did have previous success loading this model.`;
  return `You need ${requiredMemoryGb.toFixed(1)} GB of video memory to load this model. It seems unlikely to load, but you can try it.`;
}
function _describeWebGpuNotAvailable() {
  return `Your browser doesn't support WebGPU. GPU-accelerated models won't load successfully. You could try using a different browser like Google Chrome or Microsoft Edge.`;
}
function _calculatePerformance(requestTimestamp, firstResponseTimestamp, lastResponseTimestamp, inputCharCount, outputCharCount) {
  const inputTime = firstResponseTimestamp - requestTimestamp;
  const inputCharsPerSec = inputTime === 0 ? 0 : inputCharCount / inputTime * 1e3;
  const outputTime = lastResponseTimestamp - firstResponseTimestamp;
  const outputCharsPerSec = outputTime === 0 ? 0 : outputCharCount / outputTime * 1e3;
  return { inputCharsPerSec, outputCharsPerSec };
}
async function updateModelDevicePerformanceHistory(modelId, requestTime, firstResponseTime, lastResponseTime, inputCharCount, outputCharCount) {
  const { inputCharsPerSec, outputCharsPerSec } = _calculatePerformance(requestTime, firstResponseTime, lastResponseTime, inputCharCount, outputCharCount);
  if (inputCharsPerSec === 0 && outputCharsPerSec === 0) return;
  await _setCurrentModel(modelId);
  assertNonNullable(theCurrentModelInfo);
  if (inputCharsPerSec) updateMovingAverage(inputCharsPerSec, theCurrentModelInfo.history.inputCharsPerSec);
  if (outputCharsPerSec) updateMovingAverage(outputCharsPerSec, theCurrentModelInfo.history.outputCharsPerSec);
  await _saveCurrentModel();
}
async function updateModelDeviceLoadHistory(modelId, successfulLoad, loadTime = 0) {
  await _setCurrentModel(modelId);
  assertNonNullable(theCurrentModelInfo);
  const loadSuccessRate = successfulLoad ? 1 : 0;
  updateMovingAverage(loadSuccessRate, theCurrentModelInfo.history.loadSuccessRate);
  if (successfulLoad) {
    updateMovingAverage(loadTime, theCurrentModelInfo.history.loadTime);
    await incrementMaxLlmSizeAfterSuccessfulLoad(theCurrentModelInfo.requiredMemoryGb);
  }
  await _saveCurrentModel();
}
async function predictModelDeviceProblems(modelId) {
  await _setCurrentModel(modelId);
  assertNonNullable(theCurrentModelInfo);
  const problems = [];
  if (!hasWebGpuSupport()) {
    problems.push({
      type: ModelDeviceProblemType.WEBGPU_NOT_AVAILABLE,
      description: _describeWebGpuNotAvailable(),
      isBlocking: true
    });
  }
  const { loadSuccessRate } = theCurrentModelInfo.history;
  if (loadSuccessRate.series.length && loadSuccessRate.lastAverage < 1) {
    problems.push({
      type: ModelDeviceProblemType.BAD_LOAD_SUCCESS_HISTORY,
      description: _describeBadLoadSuccessHistory(loadSuccessRate),
      isBlocking: false
    });
  }
  const { inputCharsPerSec, outputCharsPerSec } = theCurrentModelInfo.history;
  if (_areTokenRatesSlow(inputCharsPerSec, outputCharsPerSec)) {
    problems.push({
      type: ModelDeviceProblemType.BAD_PERFORMANCE_HISTORY,
      description: _describeBadPerformanceHistory(inputCharsPerSec, outputCharsPerSec),
      isBlocking: false
    });
  }
  const maxLlmSize = await getMaxLlmSize();
  const wasSuccessfulBefore = loadSuccessRate.series.some((s) => s > 0);
  if (theCurrentModelInfo.requiredMemoryGb > maxLlmSize) {
    problems.push({
      type: ModelDeviceProblemType.INSUFFICIENT_VRAM,
      description: _describeInsufficientMemory(wasSuccessfulBefore, theCurrentModelInfo.requiredMemoryGb, maxLlmSize),
      isBlocking: false
    });
  }
  const availableStorage = await estimateAvailableStorage();
  if (theCurrentModelInfo.requiredStorageGb > await estimateAvailableStorage()) {
    problems.push({
      type: ModelDeviceProblemType.INSUFFICIENT_STORAGE,
      description: _describeInsufficientStorage(wasSuccessfulBefore, theCurrentModelInfo.requiredStorageGb, availableStorage),
      isBlocking: false
    });
  }
  if (isServingLocally()) {
    problems.push({
      type: ModelDeviceProblemType.DEVELOPER_MODE,
      description: `You are running this web app from a local server, probably for development.`,
      isBlocking: false
    });
  }
  return problems.length ? problems : null;
}
async function scoreModel(modelId, isBetaModel) {
  let problems = await predictModelDeviceProblems(modelId) ?? [];
  assertNonNullable(theCurrentModelInfo);
  assert(theCurrentModelInfo.modelId === modelId);
  problems = problems.filter((p) => p.type !== ModelDeviceProblemType.DEVELOPER_MODE);
  const loadCount = theCurrentModelInfo.history.loadSuccessRate.series.length;
  if (!problems.length && !isBetaModel) {
    if (!loadCount) return 50;
    assert(theCurrentModelInfo.history.loadSuccessRate.lastAverage === 1);
    if (loadCount === 1) return 60;
    if (loadCount < 3) return 75;
    return 100;
  }
  if (problems.some((p) => p.isBlocking)) return 0;
  let score = 40;
  if (!loadCount) {
    score -= 5;
  } else {
    score -= Math.round(10 * (1 - theCurrentModelInfo.history.loadSuccessRate.lastAverage));
  }
  if (problems.some((p) => p.type === ModelDeviceProblemType.INSUFFICIENT_VRAM)) score -= 10;
  if (problems.some((p) => p.type === ModelDeviceProblemType.INSUFFICIENT_STORAGE)) score -= 5;
  if (problems.some((p) => p.type === ModelDeviceProblemType.BAD_PERFORMANCE_HISTORY)) score -= 5;
  if (isBetaModel) score -= 5;
  assert(score > 0);
  return score;
}
async function findBestModel() {
  const { supportedModels } = await getAppMetaData();
  if (!supportedModels.length) throw Error("No supported LLM models for this app.");
  const appSettingValues = await getAppSettings();
  let settingsModelId = AUTO_SELECT_ID;
  if (appSettingValues) {
    const modelId = appSettingValues[APP_SETTINGS_LLM_ID];
    if (typeof modelId === "string") settingsModelId = modelId;
  }
  if (settingsModelId !== AUTO_SELECT_ID && supportedModels.some((s) => s.id === settingsModelId)) return settingsModelId;
  let bestScore = -1, bestI = -1;
  for (let modelI = 0; modelI < supportedModels.length; ++modelI) {
    const model = supportedModels[modelI];
    const score = await scoreModel(model.id, !!model.beta);
    if (score > bestScore) {
      bestScore = score;
      bestI = modelI;
    }
  }
  assert(bestI >= 0);
  return supportedModels[bestI].id;
}
var AUTO_SELECT_ID = "auto-select";
var AUTO_SELECT_OPTION = {
  id: AUTO_SELECT_ID,
  originalIndex: -1,
  displayName: "Auto Select",
  problems: null,
  inputCharsPerSec: 0,
  outputCharsPerSec: 0,
  appBehaviorSummary: "Automatically select the best model for your device and this app.",
  beta: false,
  iconChar: null
};
function _sortModelOptions(options) {
  return options.sort((a, b) => {
    if (a.beta && !b.beta) return 1;
    if (!a.beta && b.beta) return -1;
    return a.originalIndex - b.originalIndex;
  });
}
async function initModelOptions(models, setModelOptions) {
  const modelNicknames = [];
  const modelOptions = models.map((model, originalIndex) => {
    const { id, beta, appBehaviorSummary: appBehaviorSummary2 } = model;
    let displayName = nicknameModelId(id, modelNicknames);
    modelNicknames.push(displayName);
    return {
      id,
      originalIndex,
      displayName,
      problems: null,
      inputCharsPerSec: 0,
      outputCharsPerSec: 0,
      beta: !!beta,
      iconChar: null,
      appBehaviorSummary: appBehaviorSummary2
    };
  });
  const sortedModelOptions = _sortModelOptions(modelOptions);
  sortedModelOptions.unshift(AUTO_SELECT_OPTION);
  setModelOptions(modelOptions);
  const PROBLEM_ICON = "âš ", AFTER_AUTO_SELECT = 1;
  const secondModelOptions = [...sortedModelOptions];
  for (let optionI = AFTER_AUTO_SELECT; optionI < secondModelOptions.length; ++optionI) {
    const option = secondModelOptions[optionI];
    option.problems = await predictModelDeviceProblems(option.id) ?? [];
    if (option.problems.length) option.problems = option.problems.filter((o) => o.type !== ModelDeviceProblemType.DEVELOPER_MODE);
    if (option.beta) option.problems.push({ type: ModelDeviceProblemType.BETA, description: "Beta status: app has not been fully tested with this model.", isBlocking: false });
    if (!option.problems.length) option.problems = null;
    option.iconChar = option.problems ? PROBLEM_ICON : null;
    const history = await getModelDeviceHistory(option.id);
    if (history.inputCharsPerSec.series.length) option.inputCharsPerSec = history.inputCharsPerSec.lastAverage;
    if (history.outputCharsPerSec.series.length) option.outputCharsPerSec = history.outputCharsPerSec.lastAverage;
  }
  setModelOptions(secondModelOptions);
}
var APP_CATEGORY_ID = "app-";
var APP_SETTINGS_LLM_ID = "llm";
function getAppCategoryId(appId) {
  const parts = windowLocationPathname().split("/").filter((part) => part.length);
  if (!parts.length) return `${APP_CATEGORY_ID}${appId}`;
  return `${APP_CATEGORY_ID}${parts[0]}`;
}
async function _addAppLlmSettingIfMissing(settings) {
  if (settings.some((s) => s.id === APP_SETTINGS_LLM_ID)) return;
  const appMetaData = await getAppMetaData();
  settings.unshift({
    id: APP_SETTINGS_LLM_ID,
    type: SettingType.SUPPORTED_MODEL,
    label: "LLM to use",
    value: AUTO_SELECT_ID,
    models: appMetaData.supportedModels
  });
}
function _addAppLlmHeadingIfMissing(headings) {
  if (headings.some((h) => h.precedeSettingId === APP_SETTINGS_LLM_ID)) return;
  headings.unshift({
    id: "LLM",
    description: "LLM Settings Specific to This App",
    precedeSettingId: APP_SETTINGS_LLM_ID
  });
}
async function _appSettingCategoryToSettingCategory(appCategory, appId) {
  const settings = [...appCategory.settings];
  await _addAppLlmSettingIfMissing(settings);
  const headings = appCategory.headings ? [...appCategory.headings] : [];
  _addAppLlmHeadingIfMissing(headings);
  return {
    name: "This App",
    id: getAppCategoryId(appId),
    description: appCategory.description,
    headings,
    settings,
    disablementRules: appCategory.disablementRules
  };
}
async function getAppSettings() {
  const { id: appId } = await getAppMetaData();
  const id = getAppCategoryId(appId);
  return await getCategorySettings(id);
}
async function loadAppSettingCategory(defaultAppCategory, onLoadAppSettings) {
  const { id: appId } = await getAppMetaData();
  const category = await _appSettingCategoryToSettingCategory(defaultAppCategory, appId);
  let appSettings = await getAppSettings() ?? settingsToSettingValues(category.settings);
  if (onLoadAppSettings) {
    const overrideAppSettings = onLoadAppSettings(appSettings);
    if (overrideAppSettings) appSettings = overrideAppSettings;
  }
  return mergeSettingValuesIntoCategory(category, appSettings);
}
var ToastManager = class {
  _subscriptions;
  constructor() {
    this._subscriptions = [];
  }
  sendToast(message, type) {
    const toast = { message, type };
    this._subscriptions.forEach((callback) => callback(toast));
  }
  subscribe(callback) {
    if (!this._subscriptions.includes(callback)) this._subscriptions.push(callback);
  }
  unsubscribe(callback) {
    const index = this._subscriptions.indexOf(callback);
    if (index !== -1) this._subscriptions.splice(index, 1);
  }
};
var ToastType = ((ToastType2) => {
  ToastType2["INFO"] = "info";
  ToastType2["IMPORTANT"] = "important";
  ToastType2["ERROR"] = "error";
  return ToastType2;
})(ToastType || {});
var ToastState = ((ToastState2) => {
  ToastState2[ToastState2["APPEARING"] = 0] = "APPEARING";
  ToastState2[ToastState2["VISIBLE"] = 1] = "VISIBLE";
  ToastState2[ToastState2["DISAPPEARING"] = 2] = "DISAPPEARING";
  ToastState2[ToastState2["GONE"] = 3] = "GONE";
  return ToastState2;
})(ToastState || {});
var toastManager = new ToastManager();
function infoToast(message) {
  toastManager.sendToast(message, ToastType.INFO);
}
function importantToast(message) {
  toastManager.sendToast(message, ToastType.IMPORTANT);
}
function errorToast(message) {
  toastManager.sendToast(message, ToastType.ERROR);
}
function subscribeToToasts(callback) {
  toastManager.subscribe(callback);
}
function unsubscribeFromToasts(callback) {
  toastManager.unsubscribe(callback);
}
function doesToastTypeRequireDismissing(type) {
  return type === ToastType.ERROR || type === ToastType.IMPORTANT;
}
function now() {
  return Date.now();
}
function getDayPath(timestamp) {
  const date = new Date(timestamp);
  const dayPath = date.getFullYear().toString().padStart(4, "0") + "-" + (date.getMonth() + 1).toString().padStart(2, "0") + "-" + date.getDate().toString().padStart(2, "0");
  return dayPath;
}
function _dayPathToKey(dayPath) {
  return `/log/${dayPath}.txt`;
}
function _keyToDayPath(key) {
  if (!key.startsWith("/log/") || !key.endsWith(".txt")) throw Error(`Invalid log key: ${key}`);
  return key.slice(5, -4);
}
async function getLogTextForDay(dayPath) {
  const key = _dayPathToKey(dayPath);
  return await getText(key);
}
async function setLogTextForDay(dayPath, text) {
  const key = _dayPathToKey(dayPath);
  await setText(key, text);
}
async function deleteLogTextForDay(dayPath) {
  const key = _dayPathToKey(dayPath);
  await deleteByKey(key);
}
async function findAllLoggedDays() {
  const keys = await getAllKeysAtPath("/log/");
  return keys.map(_keyToDayPath).sort((a, b) => a.localeCompare(b));
}
var DEFAULT_WRITE_DELAY_MS = 3e3;
var DAY = 24 * 60 * 60 * 1e3;
var UNINITIALIZED_DAY_PATH = "UNINITIALIZED_DAY_PATH";
var theDayBuffer = [];
var theDayBufferPath = UNINITIALIZED_DAY_PATH;
var thePreviousDayPath = UNINITIALIZED_DAY_PATH;
var thePreviousDayEntryCount = 0;
var theDebouncedWriteTimer = null;
var theAppName = "";
var theLoggingSettings = null;
var theWriteDelayMs = DEFAULT_WRITE_DELAY_MS;
function _getMaxRetentionDays() {
  return theLoggingSettings && theLoggingSettings[LOGGING_SETTING_MAX_RETENTION_DAYS] || 0;
}
function _isLoggingEnabled() {
  assertNonNullable(theLoggingSettings);
  return theLoggingSettings[LOGGING_SETTING_ENABLE];
}
function _isRunningOnDedicatedWorker() {
  return typeof self !== "undefined" && self.constructor.name === "DedicatedWorkerGlobalScope";
}
async function _writeDayBuffer() {
  assert(theDayBuffer.length > 0);
  try {
    assertNonNullable(theDayBufferPath);
    if (thePreviousDayEntryCount) {
      assert(thePreviousDayPath !== UNINITIALIZED_DAY_PATH);
      const previousDayBuffer = theDayBuffer.slice(0, thePreviousDayEntryCount);
      theDayBuffer = theDayBuffer.slice(thePreviousDayEntryCount);
      await setLogTextForDay(thePreviousDayPath, previousDayBuffer.join("\n"));
      thePreviousDayEntryCount = 0;
      thePreviousDayPath = UNINITIALIZED_DAY_PATH;
    }
    await setLogTextForDay(theDayBufferPath, theDayBuffer.join("\n"));
  } catch (error) {
    console.error("Unexpected error writing log buffer:", error);
  }
}
async function _initDayBuffer(dayPath) {
  const logText = await getLogTextForDay(dayPath);
  if (logText) theDayBuffer = logText.split("\n");
  theDayBufferPath = dayPath;
}
async function log(text, flushImmediately = false) {
  if (_isRunningOnDedicatedWorker()) throw Error("Unexpected - log() should not be called in worker thread.");
  if (!theLoggingSettings) {
    console.warn("Logging settings have not been applied yet. Failed to log:", text);
    return;
  }
  if (!_isLoggingEnabled()) return;
  const timestamp = now();
  const dayPath = getDayPath(timestamp);
  if (theDayBufferPath === UNINITIALIZED_DAY_PATH) await _initDayBuffer(dayPath);
  if (theDayBufferPath !== dayPath) {
    thePreviousDayEntryCount = theDayBuffer.length;
    thePreviousDayPath = theDayBufferPath;
    theDayBufferPath = dayPath;
  }
  const date = new Date(timestamp);
  const timePrefix = date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  theDayBuffer.push(`[${timePrefix}] ${text}`);
  if (flushImmediately) {
    await _writeDayBuffer();
    return;
  }
  if (theDebouncedWriteTimer) clearTimeout(theDebouncedWriteTimer);
  theDebouncedWriteTimer = setTimeout(async () => {
    await _writeDayBuffer();
    theDebouncedWriteTimer = null;
  }, theWriteDelayMs);
}
function _getPastDayPath(daysAgo) {
  return getDayPath(now() - daysAgo * DAY);
}
async function _getLogText(includeDayCount) {
  let dayPaths = await findAllLoggedDays();
  if (!dayPaths.length) return "";
  if (includeDayCount !== Infinity) {
    const oldestDayPath = _getPastDayPath(includeDayCount);
    dayPaths = dayPaths.filter((dayPath) => dayPath > oldestDayPath);
  }
  let logText = "";
  for (let i = 0; i < dayPaths.length; ++i) {
    const dayPath = dayPaths[i];
    const dayLogText = await getLogTextForDay(dayPath);
    if (!dayLogText) {
      console.error("Non-fatal error - no log text stored for ${dayPath} despite key being present.");
      continue;
    }
    logText += `--- ${dayPath} ---
`;
    logText += dayLogText;
  }
  return logText;
}
async function copyLogsToClipboard(includeDayCount = Infinity) {
  const logText = await _getLogText(includeDayCount);
  if (!logText.length) return false;
  self.navigator.clipboard.writeText(logText);
  return true;
}
async function deleteOldLogMessages() {
  const olderThanDayCount = _getMaxRetentionDays();
  assert(olderThanDayCount > 0);
  const oldestDayPath = _getPastDayPath(olderThanDayCount);
  const dayPaths = await findAllLoggedDays();
  const dayPathsToDelete = dayPaths.filter((dayPath) => dayPath <= oldestDayPath);
  const promises = dayPathsToDelete.map(deleteLogTextForDay);
  return await Promise.all(promises);
}
async function deleteAllLogMessages() {
  const dayPathsToDelete = await findAllLoggedDays();
  const promises = dayPathsToDelete.map(deleteLogTextForDay);
  return await Promise.all(promises);
}
async function applyLoggingSettings(loggingSettings) {
  theLoggingSettings = loggingSettings;
  const maxRetentionDays = _getMaxRetentionDays();
  if (maxRetentionDays > 0) await deleteOldLogMessages();
}
function setAppName(appName2) {
  if (appName2 !== theAppName) {
    theAppName = appName2;
    log(`*** ${appName2} session ***`);
  }
}
var ButtonAction = ((ButtonAction2) => {
  ButtonAction2["COPY_ALL_LOGS"] = "copyAllLogs";
  ButtonAction2["COPY_TODAY_LOGS"] = "copyTodayLogs";
  ButtonAction2["CLEAR_LOGS"] = "clearLogs";
  return ButtonAction2;
})(ButtonAction || {});
async function onLogSettingsButtonClick(value) {
  switch (value) {
    case "copyAllLogs":
      try {
        if (await copyLogsToClipboard()) {
          infoToast("All logs copied to clipboard. You can paste them into an email, issue, etc.");
        } else {
          infoToast("No logs found.");
        }
      } catch (e) {
        console.error(e);
        errorToast("Could not copy logs to the clipboard.");
      }
      break;
    case "copyTodayLogs":
      try {
        if (await copyLogsToClipboard(1)) {
          infoToast("Todays logs copied to clipboard. You can paste them into an email, issue, etc.");
        } else {
          infoToast("No logs found for today.");
        }
      } catch (e) {
        console.error(e);
        errorToast("Could not copy logs to the clipboard.");
      }
      break;
    case "clearLogs":
      try {
        await deleteAllLogMessages();
        infoToast("Logs cleared.");
      } catch (e) {
        console.error(e);
        errorToast("Could not copy logs to the clipboard.");
      }
      break;
    default:
      botch();
  }
}
var LOGGING_CATEGORY_ID = "logging";
var LOGGING_SETTING_ENABLE = "enableLogging";
var LOGGING_SETTING_MAX_RETENTION_DAYS = "maxRetentionDays";
function _getLoggingDefaultSettings() {
  return {
    name: "Logging",
    id: LOGGING_CATEGORY_ID,
    description: "Settings for locally logging application events and errors. Logs are never sent to a server.",
    settings: [
      { type: SettingType.BOOLEAN_TOGGLE, id: LOGGING_SETTING_ENABLE, label: "Logging enabled?", value: true },
      { type: SettingType.NUMERIC, id: LOGGING_SETTING_MAX_RETENTION_DAYS, label: "Max days to keep", value: 7, minValue: 1, maxValue: 1e3, allowDecimals: false }
    ],
    headings: [
      {
        precedeSettingId: null,
        description: `Logs can be useful for troubleshooting problems with apps. You can copy them from this dialog and paste into emails, Github issues, etc.`,
        buttons: [
          { label: "Copy All Logs", value: ButtonAction.COPY_ALL_LOGS },
          { label: "Copy Logs from Today", value: ButtonAction.COPY_TODAY_LOGS },
          { label: "Clear Logs", value: ButtonAction.CLEAR_LOGS }
        ],
        /* v8 ignore next */
        onButtonClick: (value) => onLogSettingsButtonClick(value)
      }
    ],
    disablementRules: [{ targetSettingId: LOGGING_SETTING_MAX_RETENTION_DAYS, criteriaSettingId: LOGGING_SETTING_ENABLE, criteriaValue: false }]
  };
}
async function loadLoggingSettingCategory() {
  const settingValues = await getCategorySettings(LOGGING_CATEGORY_ID) ?? {};
  return mergeSettingValuesIntoCategory(_getLoggingDefaultSettings(), settingValues);
}
async function getLoggingSettings() {
  const loggingSettings = await getCategorySettings(LOGGING_CATEGORY_ID);
  if (loggingSettings) return loggingSettings;
  const defaultSettings = _getLoggingDefaultSettings();
  return settingsToSettingValues(defaultSettings.settings);
}
var theSetModalDialogName = null;
var theOpeningCategoryId = null;
function _findCategoryNoById(categories, categoryId) {
  if (categoryId.startsWith(APP_CATEGORY_ID)) return 0;
  return categories.findIndex((category) => category.id === categoryId);
}
function initOpening(setModalDialogName) {
  theSetModalDialogName = setModalDialogName;
}
function setOpeningCategoryId(categoryId) {
  theOpeningCategoryId = categoryId;
}
function findOpeningCategoryNo(categories) {
  assert(categories.length > 0);
  if (!theOpeningCategoryId) return 0;
  const selectedCategoryNo = _findCategoryNoById(categories, theOpeningCategoryId);
  assert(selectedCategoryNo >= 0);
  return selectedCategoryNo;
}
function openSettingsDialog(categoryId = APP_CATEGORY_ID) {
  if (!theSetModalDialogName) throw Error("Call openSettingsDialog() only after the DecentBar component has been rendered.");
  setOpeningCategoryId(categoryId);
  theSetModalDialogName(SettingsDialog.name);
}
function collateSettingRows(category) {
  const rows = [];
  const headings = category.headings ?? [];
  category.settings.forEach((setting) => {
    let precedingHeading = headings.find((heading2) => heading2.precedeSettingId === setting.id);
    if (precedingHeading) rows.push({ type: HEADING_TYPE, ...precedingHeading });
    rows.push(setting);
  });
  const lastHeading = headings.find((heading2) => heading2.precedeSettingId === null);
  if (lastHeading) rows.push({ type: HEADING_TYPE, ...lastHeading });
  return rows;
}
function findDisabledSettings(category) {
  if (!category.disablementRules) return [];
  const disabledSettings = [];
  category.disablementRules.forEach((rule) => {
    const criteriaSetting = category.settings.find((s) => s.id === rule.criteriaSettingId);
    if (!criteriaSetting) throw new Error(`Disablement rule for setting ${rule.targetSettingId} references non-existent criteria setting ${rule.criteriaSettingId}`);
    const criteriaValue = criteriaSetting.value;
    if (criteriaValue === rule.criteriaValue) disabledSettings.push(rule.targetSettingId);
  });
  return disabledSettings;
}
async function loadSettingCategories(defaultAppCategory, onLoadAppSettings) {
  const appCategory = await loadAppSettingCategory(defaultAppCategory, onLoadAppSettings);
  const llmCategory = await loadLlmSettingCategory();
  const loggingCategory = await loadLoggingSettingCategory();
  return [appCategory, llmCategory, loggingCategory];
}
async function saveSettingCategories(categories, onSaveAppSettings) {
  const { id: appId } = await getAppMetaData();
  const appCategoryId = getAppCategoryId(appId);
  const promises = categories.map((category) => {
    let settingValues = settingsToSettingValues(category.settings);
    switch (category.id) {
      case appCategoryId:
        if (onSaveAppSettings) {
          const overrideAppSettings = onSaveAppSettings(settingValues);
          if (overrideAppSettings) settingValues = { ...settingValues, ...overrideAppSettings };
        }
        break;
      case LOGGING_CATEGORY_ID:
        applyLoggingSettings(settingValues);
        break;
      case LLM_CATEGORY_ID:
        applyLlmSettings();
        break;
      /* v8 ignore start */
      default:
        botch();
    }
    return setCategorySettings(category.id, settingValues);
  });
  try {
    await Promise.all(promises);
  } catch (error) {
    console.error("Error saving settings:", error);
    throw new Error("Failed to save settings. Please try again later.");
  }
}
function openSettings(categoryId) {
  openSettingsDialog(categoryId);
}
async function init$1(defaultAppCategory, onLoadAppSettings) {
  return await loadSettingCategories(defaultAppCategory, onLoadAppSettings);
}
var bar = "_bar_c4j8c_6";
var label$1 = "_label_c4j8c_13 _disableSelect_mpqe1_1";
var selectorButton = "_selectorButton_c4j8c_22 _disableSelect_mpqe1_1";
var tabButton = "_tabButton_c4j8c_34";
var firstSelectorButton = "_firstSelectorButton_c4j8c_50";
var lastSelectorButton = "_lastSelectorButton_c4j8c_55";
var selectorButtonText = "_selectorButtonText_c4j8c_60";
var selectorButtonSelected = "_selectorButtonSelected_c4j8c_68 _selectorButton_c4j8c_22 _disableSelect_mpqe1_1";
var icon$1 = "_icon_c4j8c_74";
var iconDisabled = "_iconDisabled_c4j8c_83 _icon_c4j8c_74";
var selectorButtonSelectedReclickable = "_selectorButtonSelectedReclickable_c4j8c_88 _selectorButton_c4j8c_22 _disableSelect_mpqe1_1";
var selectorButtonTextSelected = "_selectorButtonTextSelected_c4j8c_98 _selectorButtonText_c4j8c_60";
var selectorButtonDisabled = "_selectorButtonDisabled_c4j8c_103 _selectorButton_c4j8c_22 _disableSelect_mpqe1_1";
var selectorButtonTextDisabled = "_selectorButtonTextDisabled_c4j8c_116 _selectorButtonText_c4j8c_60";
var styles$c = {
  bar,
  label: label$1,
  selectorButton,
  tabButton,
  firstSelectorButton,
  lastSelectorButton,
  selectorButtonText,
  selectorButtonSelected,
  icon: icon$1,
  iconDisabled,
  selectorButtonSelectedReclickable,
  selectorButtonTextSelected,
  selectorButtonDisabled,
  selectorButtonTextDisabled
};
var container$6 = "_container_iv4ss_1";
var contentBox = "_contentBox_iv4ss_6";
var styles$b = {
  container: container$6,
  contentBox
};
var Direction = ((Direction2) => {
  Direction2[Direction2["ABOVE"] = 0] = "ABOVE";
  Direction2[Direction2["BELOW"] = 1] = "BELOW";
  Direction2[Direction2["RIGHT"] = 2] = "RIGHT";
  Direction2[Direction2["LEFT"] = 3] = "LEFT";
  return Direction2;
})(Direction || {});
var DEFAULT_DIRECTIONS = [Direction.ABOVE, Direction.BELOW, Direction.RIGHT, Direction.LEFT];
function _domRectToRect(rect) {
  return {
    left: rect.left,
    top: rect.top,
    width: rect.width,
    height: rect.height
  };
}
function _calcAboveOffset(t, p) {
  let left = t.left + Math.round((t.width - p.width) / 2);
  let top = t.top - p.height;
  return [left - p.left, top - p.top];
}
function _calcBelowOffset(t, p) {
  let left = t.left + Math.round((t.width - p.width) / 2);
  let top = t.top + t.height;
  return [left - p.left, top - p.top];
}
function _calcLeftOffset(t, p) {
  let left = t.left - p.width;
  let top = t.top + Math.round((t.height - p.height) / 2);
  return [left - p.left, top - p.top];
}
function _calcRightOffset(t, p) {
  let left = t.left + t.width;
  let top = t.top + Math.round((t.height - p.height) / 2);
  return [left - p.left, top - p.top];
}
var offsetFunctions = [];
offsetFunctions[Direction.ABOVE] = _calcAboveOffset;
offsetFunctions[Direction.BELOW] = _calcBelowOffset;
offsetFunctions[Direction.LEFT] = _calcLeftOffset;
offsetFunctions[Direction.RIGHT] = _calcRightOffset;
function getTryDirections(preferredDirection, allowedDirections) {
  if (preferredDirection === void 0) preferredDirection = DEFAULT_DIRECTIONS;
  assert(allowedDirections === void 0 || allowedDirections.length > 0, "If allowedDirections is specified, it must be a non-empty array.");
  if (!Array.isArray(preferredDirection)) preferredDirection = [preferredDirection];
  const directions = [];
  preferredDirection.forEach((d) => {
    if (!directions.includes(d) && (!allowedDirections || allowedDirections.includes(d))) directions.push(d);
  });
  DEFAULT_DIRECTIONS.forEach((d) => {
    if (!directions.includes(d) && (!allowedDirections || allowedDirections.includes(d))) directions.push(d);
  });
  assert(directions.length > 0);
  return directions;
}
function _doesRectContainRect(containerRect, innerRect) {
  return containerRect.left <= innerRect.left && containerRect.top <= innerRect.top && containerRect.left + containerRect.width >= innerRect.left + innerRect.width && containerRect.top + containerRect.height >= innerRect.top + innerRect.height;
}
function _fixOobRect(containerRect, innerRect) {
  const rect = { ...innerRect };
  if (innerRect.left < containerRect.left) {
    rect.left = containerRect.left;
  } else if (innerRect.left + innerRect.width > containerRect.left + containerRect.width) {
    rect.left = containerRect.left + containerRect.width - innerRect.width;
  }
  if (innerRect.top < containerRect.top) {
    rect.top = containerRect.top;
  } else if (innerRect.top + innerRect.height > containerRect.top + containerRect.height) {
    rect.top = containerRect.top + containerRect.height - innerRect.height;
  }
  return rect;
}
function calcPopoverPositionStyle(tryDirections, targetElement, popoverContentElement) {
  const targetRect = _domRectToRect(targetElement.getBoundingClientRect());
  const popoverRect = _domRectToRect(popoverContentElement.getBoundingClientRect());
  const browserRect = _domRectToRect(browserClientRect());
  const tryRect = { ...popoverRect };
  let dx = 0, dy = 0, firstDx = 0, firstDy = 0, directionI = 0;
  for (; directionI < tryDirections.length; ++directionI) {
    const direction = tryDirections[directionI];
    [dx, dy] = offsetFunctions[direction](targetRect, popoverRect);
    if (directionI === 0) {
      firstDx = dx;
      firstDy = dy;
    }
    tryRect.left = popoverRect.left + dx;
    tryRect.top = popoverRect.top + dy;
    if (_doesRectContainRect(browserRect, tryRect)) break;
  }
  if (directionI === tryDirections.length) {
    tryRect.left = popoverRect.left + firstDx;
    tryRect.top = popoverRect.top + firstDy;
    const fixedRect = _fixOobRect(browserRect, tryRect);
    dx = fixedRect.left - popoverRect.left;
    dy = fixedRect.top - popoverRect.top;
  }
  return { transform: `translate(${dx}px, ${dy}px)` };
}
var POPOVER_HIDDEN_STYLE = { "visibility": "hidden" };
function Popover({ children, content, preferredDirection, allowedDirections }) {
  const [isOpen, setIsOpen] = (0, import_react.useState)(false);
  const [tryDirections, setTryDirections] = (0, import_react.useState)([]);
  const [popoverPositionStyle, setPopoverPositionStyle] = (0, import_react.useState)({});
  const containerRef = (0, import_react.useRef)(null);
  const contentRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const directions = getTryDirections(preferredDirection, allowedDirections);
    setTryDirections(directions);
  }, []);
  const contentBoxStyle = isOpen ? popoverPositionStyle : POPOVER_HIDDEN_STYLE;
  function _onMouseOver(event) {
    if (!containerRef.current || !contentRef.current || isOpen) return;
    const relatedTarget = event.relatedTarget;
    if (relatedTarget && containerRef.current.contains(relatedTarget)) return;
    const nextPopoverPositionStyle = calcPopoverPositionStyle(tryDirections, containerRef.current, contentRef.current);
    setPopoverPositionStyle(nextPopoverPositionStyle);
    setIsOpen(true);
  }
  function _onMouseOut(event) {
    if (!containerRef.current || !contentRef.current || !isOpen) return;
    const relatedTarget = event.relatedTarget;
    const isInsideContent = contentRef.current.contains(relatedTarget);
    const isInsideContainer = containerRef.current.contains(relatedTarget);
    if (isInsideContainer || isInsideContent) return;
    setIsOpen(false);
  }
  const popoverContent = (0, import_react_dom.createPortal)(jsxRuntimeExports.jsx("div", { className: styles$b.contentBox, style: contentBoxStyle, ref: contentRef, onMouseOut: _onMouseOut, children: content }), document.body);
  return jsxRuntimeExports.jsxs("div", { className: styles$b.container, ref: containerRef, children: [
    jsxRuntimeExports.jsx("div", { onMouseOver: _onMouseOver, onMouseOut: _onMouseOut, children }),
    popoverContent
  ] });
}
function Selector({
  disabled,
  label: label2,
  optionNames,
  onClick,
  onChange,
  selectedOptionNo,
  displayAsTabs,
  popoverContent,
  popoverPreferredDirection,
  popoverAllowedDirections,
  iconChars
}) {
  function _onOptionClick(optionNo) {
    if (disabled) return;
    if (onClick) onClick(optionNo);
    if (optionNo === selectedOptionNo) return;
    if (onChange) onChange(optionNo);
  }
  const iconClass = disabled ? styles$c.iconDisabled : styles$c.icon;
  const options = optionNames.map((optionName, optionNo) => {
    const reclickableSelection = onClick !== void 0;
    const selectorButtonSelected2 = reclickableSelection ? styles$c.selectorButtonSelectedReclickable : styles$c.selectorButtonSelected;
    const selected = optionNo === selectedOptionNo;
    let buttonClass = disabled ? styles$c.selectorButtonDisabled : selected ? selectorButtonSelected2 : styles$c.selectorButton;
    const textClass = disabled ? styles$c.selectorButtonTextDisabled : selected ? styles$c.selectorButtonTextSelected : styles$c.selectorButtonText;
    if (displayAsTabs) {
      buttonClass = `${buttonClass} ${styles$c.tabButton}`;
    } else {
      if (optionNo === 0) buttonClass = `${buttonClass} ${styles$c.firstSelectorButton}`;
      if (optionNo === optionNames.length - 1) buttonClass = `${buttonClass} ${styles$c.lastSelectorButton}`;
    }
    const iconContent = iconChars && iconChars[optionNo] ? jsxRuntimeExports.jsx("span", { className: iconClass, children: iconChars[optionNo] }) : null;
    const optionButtonContent = jsxRuntimeExports.jsxs("button", { className: buttonClass, onClick: () => _onOptionClick(optionNo), disabled, children: [
      iconContent,
      jsxRuntimeExports.jsx("span", { className: textClass, children: optionName })
    ] }, optionName);
    return popoverContent ? jsxRuntimeExports.jsx(Popover, { content: popoverContent[optionNo], preferredDirection: popoverPreferredDirection, allowedDirections: popoverAllowedDirections, children: optionButtonContent }, optionName) : optionButtonContent;
  });
  const labelElement = label2 ? jsxRuntimeExports.jsxs("span", { className: styles$c.label, children: [
    label2,
    ":"
  ] }) : null;
  return jsxRuntimeExports.jsxs("div", { className: styles$c.bar, children: [
    labelElement,
    options
  ] });
}
function SettingsCategorySelector({ categoryNames, selectedCategoryNo, onChange, disabled }) {
  return jsxRuntimeExports.jsx(Selector, { optionNames: categoryNames, selectedOptionNo: selectedCategoryNo, onChange, disabled, displayAsTabs: true });
}
var container$5 = "_container_1dxqw_4";
var setterList = "_setterList_1dxqw_29";
var styles$a = {
  container: container$5,
  setterList
};
var container$4 = "_container_1vhj3_4";
var label = "_label_1vhj3_14";
var labelDisabled = "_labelDisabled_1vhj3_22 _label_1vhj3_14";
var heading = "_heading_1vhj3_27";
var headingDisabled = "_headingDisabled_1vhj3_37 _heading_1vhj3_27";
var validationMessage = "_validationMessage_1vhj3_61";
var styles$9 = {
  container: container$4,
  label,
  labelDisabled,
  heading,
  headingDisabled,
  validationMessage
};
var LAST_VALID_VALUE = "LAST_VALID_VALUE";
var theValidationMessageDelayMs = 3e3;
var theValidationMessageTimers = /* @__PURE__ */ new Map();
function _clearValidationMessageTimer(settingId) {
  const previousTimer = theValidationMessageTimers.get(settingId);
  if (previousTimer) {
    clearTimeout(previousTimer);
    theValidationMessageTimers.delete(settingId);
  }
}
function _setValidationMessageTimer(settingId, setValidationMessage) {
  _clearValidationMessageTimer(settingId);
  const timer = setTimeout(() => {
    setValidationMessage(null);
    theValidationMessageTimers.delete(settingId);
  }, theValidationMessageDelayMs);
  theValidationMessageTimers.set(settingId, timer);
}
function handleValidation(nextSetting, lastValidValue, setValidationMessage, onValidateSetting) {
  if (!onValidateSetting) {
    setValidationMessage(null);
    return true;
  }
  const validationFailure = onValidateSetting(nextSetting.id, nextSetting.value);
  if (validationFailure) {
    _clearValidationMessageTimer(nextSetting.id);
    setValidationMessage(validationFailure.failReason ?? null);
    if (validationFailure.nextValue !== void 0) {
      nextSetting.value = validationFailure.nextValue === LAST_VALID_VALUE ? lastValidValue : validationFailure.nextValue;
      if (validationFailure.failReason) _setValidationMessageTimer(nextSetting.id, setValidationMessage);
      return true;
    }
    return false;
  }
  setValidationMessage(null);
  return true;
}
function BooleanToggleSetter({ setting, onChange, onValidateSetting, disabled }) {
  const [lastValidValue, setLastValidValue] = (0, import_react.useState)(setting.value);
  const [validationMessage2, setValidationMessage] = (0, import_react.useState)(null);
  function _onChange(value) {
    const nextSetting = { ...setting, value };
    const isValid = handleValidation(nextSetting, lastValidValue, setValidationMessage, onValidateSetting);
    if (isValid) setLastValidValue(nextSetting.value);
    onChange(nextSetting, isValid);
  }
  const validationContent = validationMessage2 ? jsxRuntimeExports.jsx("div", { className: styles$9.validationMessage, children: validationMessage2 }) : null;
  const optionNames = [setting.falseLabel ?? "No", setting.trueLabel ?? "Yes"];
  const labelClass = disabled ? styles$9.labelDisabled : styles$9.label;
  return jsxRuntimeExports.jsxs("div", { className: styles$9.container, children: [
    jsxRuntimeExports.jsx("span", { className: labelClass, children: setting.label }),
    jsxRuntimeExports.jsx(Selector, { optionNames, selectedOptionNo: setting.value ? 1 : 0, onChange: (optionNo) => _onChange(optionNo === 1), disabled }),
    validationContent
  ] });
}
function _stripNonNumeric(text) {
  return text.replace(/[^0-9.-]/g, "");
}
function getDigitCount(value) {
  if (value === 0) return 1;
  let digitCount = Math.floor(Math.log10(Math.abs(value))) + 1;
  if (value < 0) digitCount++;
  return digitCount;
}
function _createDigitWidthStyle(minValue, maxValue, allowDecimals, digitWidth) {
  let digitCount = digitWidth ?? Math.max(getDigitCount(minValue), getDigitCount(maxValue));
  if (allowDecimals) digitCount += 2;
  if (!digitCount) return {};
  return { width: `calc(${digitCount}ch + 1vh)` };
}
function NumericInput({ minValue, maxValue, value, onChange, className, allowDecimals, digitWidth, disabled }) {
  const [inputValue, setInputValue] = (0, import_react.useState)(value.toString());
  const [digitWidthStyle, setDigitWidthStyle] = (0, import_react.useState)({});
  (0, import_react.useEffect)(() => {
    assert(value >= minValue && value <= maxValue);
    setInputValue(value.toString());
  }, [value]);
  (0, import_react.useEffect)(() => {
    const nextDigitWidthStyle = _createDigitWidthStyle(minValue, maxValue, allowDecimals, digitWidth);
    setDigitWidthStyle(nextDigitWidthStyle);
  }, [digitWidth, minValue, maxValue, allowDecimals]);
  function _textToValidNumber(text) {
    try {
      let number = Number(text);
      if (isNaN(number)) text = _stripNonNumeric(text);
      number = Number(text);
      if (!allowDecimals) number = Math.round(number);
      if (number < minValue || isNaN(number)) return minValue;
      return number > maxValue ? maxValue : number;
    } catch (error) {
      return minValue;
    }
  }
  function _handleChange(text) {
    setInputValue(text);
    const number = _textToValidNumber(text);
    if ("" + number === text) onChange(number);
  }
  function _handleBlur(text) {
    const number = _textToValidNumber(text);
    if ("" + number !== text) setInputValue(number.toString());
    onChange(number);
  }
  return jsxRuntimeExports.jsx(
    "input",
    {
      type: "text",
      value: inputValue,
      style: digitWidthStyle,
      className,
      onChange: (event) => _handleChange(event.target.value),
      onBlur: (event) => _handleBlur(event.target.value),
      disabled
    }
  );
}
function NumericSetter({ setting, onChange, onValidateSetting, disabled }) {
  const [lastValidValue, setLastValidValue] = (0, import_react.useState)(setting.value);
  const [validationMessage2, setValidationMessage] = (0, import_react.useState)(null);
  function _onChange(value) {
    const nextSetting = { ...setting, value };
    const isValid = handleValidation(nextSetting, lastValidValue, setValidationMessage, onValidateSetting);
    if (isValid) setLastValidValue(nextSetting.value);
    onChange(nextSetting, isValid);
  }
  const validationContent = validationMessage2 ? jsxRuntimeExports.jsx("div", { className: styles$9.validationMessage, children: validationMessage2 }) : null;
  const labelClass = disabled ? styles$9.labelDisabled : styles$9.label;
  return jsxRuntimeExports.jsxs("div", { className: styles$9.container, children: [
    jsxRuntimeExports.jsx("span", { className: labelClass, children: setting.label }),
    jsxRuntimeExports.jsx(
      NumericInput,
      {
        minValue: setting.minValue,
        maxValue: setting.maxValue,
        allowDecimals: setting.allowDecimals,
        value: setting.value,
        onChange: _onChange,
        disabled
      }
    ),
    validationContent
  ] });
}
function TextSetter({ setting, onChange, onValidateSetting, disabled }) {
  const [validationMessage2, setValidationMessage] = (0, import_react.useState)(null);
  const [lastValidValue, setLastValidValue] = (0, import_react.useState)(setting.value);
  function _onChange(value) {
    const nextSetting = { ...setting, value };
    const isValid = handleValidation(nextSetting, lastValidValue, setValidationMessage, onValidateSetting);
    if (isValid) setLastValidValue(nextSetting.value);
    onChange(nextSetting, isValid);
  }
  const validationContent = validationMessage2 ? jsxRuntimeExports.jsx("div", { className: styles$9.validationMessage, children: validationMessage2 }) : null;
  const labelClass = disabled ? styles$9.labelDisabled : styles$9.label;
  return jsxRuntimeExports.jsxs("div", { className: styles$9.container, children: [
    jsxRuntimeExports.jsx("span", { className: labelClass, children: setting.label }),
    jsxRuntimeExports.jsx(
      "input",
      {
        id: setting.id,
        type: "text",
        value: setting.value,
        onChange: (e) => _onChange(e.target.value),
        placeholder: setting.placeholder,
        disabled
      }
    ),
    validationContent
  ] });
}
var headingButton = "_headingButton_1gpxc_6 _disableSelect_mpqe1_1";
var headingButtonText = "_headingButtonText_1gpxc_29";
var headingButtonDisabled = "_headingButtonDisabled_1gpxc_35 _headingButton_1gpxc_6 _disableSelect_mpqe1_1";
var headingButtonTextDisabled = "_headingButtonTextDisabled_1gpxc_45 _headingButtonText_1gpxc_29";
var styles$8 = {
  headingButton,
  headingButtonText,
  headingButtonDisabled,
  headingButtonTextDisabled
};
function HeadingButton({ text, onClick, disabled }) {
  const buttonClass = disabled ? styles$8.headingButtonDisabled : styles$8.headingButton;
  const textClass = disabled ? styles$8.headingButtonTextDisabled : styles$8.headingButtonText;
  return jsxRuntimeExports.jsx("button", { className: buttonClass, onClick, disabled, children: jsxRuntimeExports.jsx("span", { className: textClass, children: text }) });
}
function _renderButtons(heading2, disabled) {
  if (!heading2.buttons) return null;
  return heading2.buttons.map((button) => {
    return jsxRuntimeExports.jsx(HeadingButton, { text: button.label, onClick: () => heading2.onButtonClick?.(button.value), disabled }, button.value);
  });
}
function Heading({ heading: heading2, disabled }) {
  const buttonsContent = !heading2.buttons ? null : jsxRuntimeExports.jsx("div", { className: styles$9.buttonsContainer, children: _renderButtons(heading2, disabled) });
  const headingClass = disabled ? styles$9.headingDisabled : styles$9.heading;
  return jsxRuntimeExports.jsxs("div", { className: headingClass, children: [
    jsxRuntimeExports.jsx("p", { children: heading2.description }),
    buttonsContent
  ] });
}
var container$3 = "_container_t15oa_1";
var modelIdText$1 = "_modelIdText_t15oa_9";
var appBehaviorSummary = "_appBehaviorSummary_t15oa_20";
var speedContainer = "_speedContainer_t15oa_27";
var styles$7 = {
  container: container$3,
  modelIdText: modelIdText$1,
  appBehaviorSummary,
  speedContainer
};
var container$2 = "_container_dabnx_1";
var progressBar = "_progressBar_dabnx_16";
var overTextBar = "_overTextBar_dabnx_24";
var inputSpeedBox = "_inputSpeedBox_dabnx_34 _speedBox_dabnx_5";
var outputSpeedBox = "_outputSpeedBox_dabnx_40 _speedBox_dabnx_5";
var styles$6 = {
  container: container$2,
  progressBar,
  overTextBar,
  inputSpeedBox,
  outputSpeedBox
};
function _getRateText(prefix, rate) {
  if (rate === void 0 || rate === 0) return `${prefix}: unknown`;
  if (rate !== Math.round(rate)) rate = Math.round(rate * 10) / 10;
  return `${prefix}: ${rate} chars/sec`;
}
var INPUT_PREFIX = "input";
var OUTPUT_PREFIX = "output";
function _calcRenderTiming(inputCharsPerSec, outputCharsPerSec) {
  const startTime = Date.now();
  const inputDuration = inputCharsPerSec === void 0 ? 0 : _getRateText(INPUT_PREFIX, inputCharsPerSec).length / inputCharsPerSec * 1e3;
  const outputDuration = outputCharsPerSec === void 0 ? 0 : _getRateText(OUTPUT_PREFIX, outputCharsPerSec).length / outputCharsPerSec * 1e3;
  return { startTime, inputDuration, outputDuration };
}
function _calcProgress(renderTiming) {
  const { startTime, inputDuration, outputDuration } = renderTiming;
  const overallTime = inputDuration + outputDuration;
  const elapsed = (Date.now() - startTime) % overallTime;
  let inputProgress = 0, outputProgress = 0;
  if (elapsed < inputDuration) {
    inputProgress = elapsed / inputDuration;
  } else {
    inputProgress = 1;
    outputProgress = (elapsed - inputDuration) / outputDuration;
  }
  return { inputProgress, outputProgress };
}
var FRAMES_PER_SEC = 20;
var FRAME_INTERVAL = 1e3 / FRAMES_PER_SEC;
function LlmSpeed({ inputCharsPerSec, outputCharsPerSec }) {
  const [frameNo, setFrameNo] = (0, import_react.useState)(0);
  const [renderTiming] = (0, import_react.useState)(_calcRenderTiming(inputCharsPerSec, outputCharsPerSec));
  const inputText = (0, import_react.useMemo)(() => _getRateText("input", inputCharsPerSec), [inputCharsPerSec]);
  const outputText = (0, import_react.useMemo)(() => _getRateText("output", outputCharsPerSec), [outputCharsPerSec]);
  const { inputProgress, outputProgress } = _calcProgress(renderTiming);
  (0, import_react.useEffect)(() => {
    const interval = setTimeout(() => {
      setFrameNo(frameNo + 1);
    }, FRAME_INTERVAL);
    return () => clearInterval(interval);
  }, [frameNo]);
  return jsxRuntimeExports.jsxs("div", { className: styles$6.container, children: [
    jsxRuntimeExports.jsxs("div", { className: styles$6.inputSpeedBox, children: [
      jsxRuntimeExports.jsx(
        "div",
        {
          className: styles$6.progressBar,
          style: { width: `${inputProgress * 100}%` }
        }
      ),
      jsxRuntimeExports.jsx(
        "div",
        {
          className: styles$6.overTextBar,
          style: { width: `${(1 - inputProgress) * 100}%` }
        }
      ),
      inputText
    ] }),
    jsxRuntimeExports.jsxs("div", { className: styles$6.outputSpeedBox, children: [
      jsxRuntimeExports.jsx(
        "div",
        {
          className: styles$6.progressBar,
          style: { width: `${outputProgress * 100}%` }
        }
      ),
      jsxRuntimeExports.jsx(
        "div",
        {
          className: styles$6.overTextBar,
          style: { width: `${(1 - outputProgress) * 100}%` }
        }
      ),
      outputText
    ] })
  ] });
}
var problemList = "_problemList_1a0tc_4";
var icon = "_icon_1a0tc_20";
var styles$5 = {
  problemList,
  icon
};
var InsufficientMemoryIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M17,17H7V7H17M21,11V9H19V7C19,5.89%2018.1,5%2017,5H15V3H13V5H11V3H9V5H7C5.89,5%205,5.89%205,7V9H3V11H5V13H3V15H5V17A2,2%200%200,0%207,19H9V21H11V19H13V21H15V19H17A2,2%200%200,0%2019,17V15H21V13H19V11M13,13H11V11H13M15,9H9V15H15V9Z'%20/%3e%3c/svg%3e";
var InsufficientStorageIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M12,3C7.58,3%204,4.79%204,7C4,9.21%207.58,11%2012,11C16.42,11%2020,9.21%2020,7C20,4.79%2016.42,3%2012,3M4,9V12C4,14.21%207.58,16%2012,16C16.42,16%2020,14.21%2020,12V9C20,11.21%2016.42,13%2012,13C7.58,13%204,11.21%204,9M4,14V17C4,19.21%207.58,21%2012,21C16.42,21%2020,19.21%2020,17V14C20,16.21%2016.42,18%2012,18C7.58,18%204,16.21%204,14Z'%20/%3e%3c/svg%3e";
var BadLoadSuccessIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M13%2011H11V5H13M13%2015H11V13H13M20%202H4C2.9%202%202%202.9%202%204V22L6%2018H20C21.1%2018%2022%2017.1%2022%2016V4C22%202.9%2021.1%202%2020%202Z'%20/%3e%3c/svg%3e";
var BadPerformanceIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M12%2016C13.66%2016%2015%2014.66%2015%2013C15%2011.88%2014.39%2010.9%2013.5%2010.39L3.79%204.77L9.32%2014.35C9.82%2015.33%2010.83%2016%2012%2016M12%203C10.19%203%208.5%203.5%207.03%204.32L9.13%205.53C10%205.19%2011%205%2012%205C16.42%205%2020%208.58%2020%2013C20%2015.21%2019.11%2017.21%2017.66%2018.65H17.65C17.26%2019.04%2017.26%2019.67%2017.65%2020.06C18.04%2020.45%2018.68%2020.45%2019.07%2020.07C20.88%2018.26%2022%2015.76%2022%2013C22%207.5%2017.5%203%2012%203M2%2013C2%2015.76%203.12%2018.26%204.93%2020.07C5.32%2020.45%205.95%2020.45%206.34%2020.06C6.73%2019.67%206.73%2019.04%206.34%2018.65C4.89%2017.2%204%2015.21%204%2013C4%2012%204.19%2011%204.54%2010.1L3.33%208C2.5%209.5%202%2011.18%202%2013Z'%20/%3e%3c/svg%3e";
var DeveloperIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M8,3A2,2%200%200,0%206,5V9A2,2%200%200,1%204,11H3V13H4A2,2%200%200,1%206,15V19A2,2%200%200,0%208,21H10V19H8V14A2,2%200%200,0%206,12A2,2%200%200,0%208,10V5H10V3M16,3A2,2%200%200,1%2018,5V9A2,2%200%200,0%2020,11H21V13H20A2,2%200%200,0%2018,15V19A2,2%200%200,1%2016,21H14V19H16V14A2,2%200%200,1%2018,12A2,2%200%200,1%2016,10V5H14V3H16Z'%20/%3e%3c/svg%3e";
var BetaIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2024%2024'%3e%3cpath%20d='M9.23,17.59V23.12H6.88V6.72C6.88,5.27%207.31,4.13%208.16,3.28C9,2.43%2010.17,2%2011.61,2C13,2%2014.07,2.34%2014.87,3C15.66,3.68%2016.05,4.62%2016.05,5.81C16.05,6.63%2015.79,7.4%2015.27,8.11C14.75,8.82%2014.08,9.31%2013.25,9.58V9.62C14.5,9.82%2015.47,10.27%2016.13,11C16.79,11.71%2017.12,12.62%2017.12,13.74C17.12,15.06%2016.66,16.14%2015.75,16.97C14.83,17.8%2013.63,18.21%2012.13,18.21C11.07,18.21%2010.1,18%209.23,17.59M10.72,10.75V8.83C11.59,8.72%2012.3,8.4%2012.87,7.86C13.43,7.31%2013.71,6.7%2013.71,6C13.71,4.62%2013,3.92%2011.6,3.92C10.84,3.92%2010.25,4.16%209.84,4.65C9.43,5.14%209.23,5.82%209.23,6.71V15.5C10.14,16.03%2011.03,16.29%2011.89,16.29C12.73,16.29%2013.39,16.07%2013.86,15.64C14.33,15.2%2014.56,14.58%2014.56,13.79C14.56,12%2013.28,11%2010.72,10.75Z'%20/%3e%3c/svg%3e";
function _renderProblemIcon(problemType) {
  switch (problemType) {
    case ModelDeviceProblemType.INSUFFICIENT_VRAM:
      return jsxRuntimeExports.jsx("img", { className: styles$5.icon, src: InsufficientMemoryIcon, alt: "Insufficient VRAM" });
    case ModelDeviceProblemType.INSUFFICIENT_STORAGE:
      return jsxRuntimeExports.jsx("img", { className: styles$5.icon, src: InsufficientStorageIcon, alt: "Insufficient Storage" });
    case ModelDeviceProblemType.BAD_LOAD_SUCCESS_HISTORY:
      return jsxRuntimeExports.jsx("img", { className: styles$5.icon, src: BadLoadSuccessIcon, alt: "Bad Load Success History" });
    case ModelDeviceProblemType.BAD_PERFORMANCE_HISTORY:
      return jsxRuntimeExports.jsx("img", { className: styles$5.icon, src: BadPerformanceIcon, alt: "Bad Performance History" });
    case ModelDeviceProblemType.WEBGPU_NOT_AVAILABLE:
      return jsxRuntimeExports.jsx("img", { className: styles$5.icon, src: InsufficientMemoryIcon, alt: "WebGPU Not Available" });
    case ModelDeviceProblemType.DEVELOPER_MODE:
      return jsxRuntimeExports.jsx("img", { className: styles$5.icon, src: DeveloperIcon, alt: "Developer Mode" });
    case ModelDeviceProblemType.BETA:
      return jsxRuntimeExports.jsx("img", { className: styles$5.icon, src: BetaIcon, alt: "Beta" });
    default:
      botch();
  }
}
function ModelDeviceProblemsList({ problems }) {
  if (!problems) return null;
  assert(problems.length >= 1);
  const problemsContent = problems.map((problem, problemI) => {
    return jsxRuntimeExports.jsxs("li", { children: [
      _renderProblemIcon(problem.type),
      problem.description
    ] }, problemI);
  });
  return jsxRuntimeExports.jsx("ul", { className: styles$5.problemList, children: problemsContent });
}
function SupportedModelPopoverContent({ modelId, appBehaviorSummary: appBehaviorSummary2, problems, inputCharsPerSec, outputCharsPerSec }) {
  const speedContent = inputCharsPerSec > 0 || outputCharsPerSec > 0 ? jsxRuntimeExports.jsx("div", { className: styles$7.speedContainer, children: jsxRuntimeExports.jsx(LlmSpeed, { inputCharsPerSec, outputCharsPerSec }) }) : null;
  const modelIdContent = modelId === AUTO_SELECT_ID ? "Auto Select Model" : modelId;
  return jsxRuntimeExports.jsxs("div", { className: styles$7.container, children: [
    jsxRuntimeExports.jsx("div", { className: styles$7.modelIdText, children: modelIdContent }),
    jsxRuntimeExports.jsx("p", { className: styles$7.appBehaviorSummary, children: appBehaviorSummary2 }),
    jsxRuntimeExports.jsx(ModelDeviceProblemsList, { problems }),
    speedContent
  ] });
}
function _renderPopoverContent(modelOptions) {
  return modelOptions.map((option) => jsxRuntimeExports.jsx(
    SupportedModelPopoverContent,
    {
      modelId: option.id,
      appBehaviorSummary: option.appBehaviorSummary,
      problems: option.problems,
      inputCharsPerSec: option.inputCharsPerSec,
      outputCharsPerSec: option.outputCharsPerSec
    },
    option.id
  ));
}
function SupportedModelSetter({ setting, onChange, onValidateSetting, disabled }) {
  const [lastValidValue, setLastValidValue] = (0, import_react.useState)(setting.value);
  const [validationMessage2, setValidationMessage] = (0, import_react.useState)(null);
  const [modelOptions, setModelOptions] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    initModelOptions(setting.models, setModelOptions);
  }, [setting.models]);
  function _onChange(nextModelId) {
    const nextSetting = { ...setting, value: nextModelId };
    const isValid = handleValidation(nextSetting, lastValidValue, setValidationMessage, onValidateSetting);
    if (isValid) setLastValidValue(nextSetting.value);
    onChange(nextSetting, isValid);
  }
  const validationContent = validationMessage2 ? jsxRuntimeExports.jsx("div", { className: styles$9.validationMessage, children: validationMessage2 }) : null;
  const availableModelCount = setting.models.length;
  const labelClass = disabled ? styles$9.labelDisabled : styles$9.label;
  const popoverContent = _renderPopoverContent(modelOptions);
  let selectedOptionNo = modelOptions.findIndex((o) => o.id === setting.value);
  if (selectedOptionNo === -1) selectedOptionNo = 0;
  const content = availableModelCount === 0 ? jsxRuntimeExports.jsx("span", { children: "LLM is not used by app." }) : jsxRuntimeExports.jsx(
    Selector,
    {
      optionNames: modelOptions.map((o) => o.displayName),
      iconChars: modelOptions.map((o) => o.iconChar),
      selectedOptionNo,
      onChange: (optionI) => _onChange(modelOptions[optionI].id),
      disabled,
      popoverContent,
      popoverPreferredDirection: Direction.BELOW
    }
  );
  return jsxRuntimeExports.jsxs("div", { className: styles$9.container, children: [
    jsxRuntimeExports.jsx("span", { className: labelClass, children: setting.label }),
    content,
    validationContent
  ] });
}
function _onChangeSetting(category, settingNo, nextSetting, isValid, validities, setValidities, onChange) {
  const nextCategoryValidities = [...validities];
  if (validities[settingNo] !== isValid) {
    nextCategoryValidities[settingNo] = isValid;
    setValidities(nextCategoryValidities);
  }
  const isEverySettingValid = !nextCategoryValidities.includes(false);
  const nextCategory = { ...category };
  nextCategory.settings[settingNo] = nextSetting;
  onChange(nextCategory, isEverySettingValid);
}
function _renderSetters(category, validities, setValidities, onChange, onValidateSetting) {
  const setterRows = collateSettingRows(category);
  if (!setterRows.length) return jsxRuntimeExports.jsx("p", { children: "No settings are available." });
  const disabledSettings = findDisabledSettings(category);
  return setterRows.map((settingRow, settingRowNo) => {
    const settingNo = category.settings.findIndex((s) => s.id === settingRow.id);
    switch (settingRow.type) {
      case SettingType.BOOLEAN_TOGGLE:
        const booleanToggleSetting = settingRow;
        return jsxRuntimeExports.jsx(
          BooleanToggleSetter,
          {
            setting: booleanToggleSetting,
            onValidateSetting,
            onChange: (nextSetting, isValid) => _onChangeSetting(category, settingNo, nextSetting, isValid, validities, setValidities, onChange),
            disabled: disabledSettings.includes(booleanToggleSetting.id)
          },
          settingRow.id
        );
      case SettingType.NUMERIC:
        const numericSetting = settingRow;
        return jsxRuntimeExports.jsx(
          NumericSetter,
          {
            setting: numericSetting,
            onValidateSetting,
            onChange: (nextSetting, isValid) => _onChangeSetting(category, settingNo, nextSetting, isValid, validities, setValidities, onChange),
            disabled: disabledSettings.includes(numericSetting.id)
          },
          settingRow.id
        );
      case SettingType.TEXT:
        const textSetting = settingRow;
        return jsxRuntimeExports.jsx(
          TextSetter,
          {
            setting: textSetting,
            onValidateSetting,
            onChange: (nextSetting, isValid) => _onChangeSetting(category, settingNo, nextSetting, isValid, validities, setValidities, onChange),
            disabled: disabledSettings.includes(textSetting.id)
          },
          settingRow.id
        );
      case SettingType.SUPPORTED_MODEL:
        const supportedModelSetting = settingRow;
        return jsxRuntimeExports.jsx(
          SupportedModelSetter,
          {
            setting: supportedModelSetting,
            onValidateSetting,
            onChange: (nextSetting, isValid) => _onChangeSetting(category, settingNo, nextSetting, isValid, validities, setValidities, onChange),
            disabled: disabledSettings.includes(supportedModelSetting.id)
          },
          settingRow.id
        );
      case HEADING_TYPE:
        return jsxRuntimeExports.jsx(Heading, { heading: settingRow }, `heading@${settingRowNo}`);
      default:
        throw Error("Unexpected");
    }
  });
}
function SettingCategoryPanel({ category, onValidateSetting, onChange, isOpen }) {
  const [validities, setValidities] = (0, import_react.useState)(Array(category.settings.length).fill(true));
  const settersContent = _renderSetters(category, validities, setValidities, onChange, onValidateSetting);
  if (!isOpen) return null;
  return jsxRuntimeExports.jsxs("div", { className: styles$a.container, children: [
    jsxRuntimeExports.jsx("p", { children: category.description }),
    jsxRuntimeExports.jsx("div", { className: styles$a.setterList, children: settersContent })
  ] });
}
var container$1 = "_container_1ldt5_1";
var styles$4 = {
  container: container$1
};
function DialogFooter(props) {
  const { children } = props;
  return jsxRuntimeExports.jsx("div", { className: styles$4.container, children });
}
var dialogButton = "_dialogButton_1e5oo_6 _disableSelect_mpqe1_1";
var dialogButtonText = "_dialogButtonText_1e5oo_28";
var dialogButtonDisabled = "_dialogButtonDisabled_1e5oo_34 _dialogButton_1e5oo_6 _disableSelect_mpqe1_1";
var dialogButtonTextDisabled = "_dialogButtonTextDisabled_1e5oo_44 _dialogButtonText_1e5oo_28";
var dialogButtonPrimary = "_dialogButtonPrimary_1e5oo_49 _dialogButton_1e5oo_6 _disableSelect_mpqe1_1";
var styles$3 = {
  dialogButton,
  dialogButtonText,
  dialogButtonDisabled,
  dialogButtonTextDisabled,
  dialogButtonPrimary
};
function DialogButton(props) {
  const { text, onClick, disabled, isPrimary } = props;
  const buttonClass = disabled ? styles$3.dialogButtonDisabled : isPrimary ? styles$3.dialogButtonPrimary : styles$3.dialogButton;
  const textClass = disabled ? styles$3.dialogButtonTextDisabled : styles$3.dialogButtonText;
  return jsxRuntimeExports.jsx("button", { className: buttonClass, onClick, disabled, children: jsxRuntimeExports.jsx("span", { className: textClass, children: text }) });
}
async function saveAndClose(categories, onClose, onSaveAppSettings) {
  await saveSettingCategories(categories, onSaveAppSettings);
  onClose(categories[0].settings);
}
function PageRefreshConfirmDialog(props) {
  const { isOpen, onCancel, onConfirm } = props;
  return jsxRuntimeExports.jsxs(ModalDialog, { isOpen, title: "LLM Changed", onCancel, children: [
    jsxRuntimeExports.jsx("p", { children: "Would you like to reload the app to use the new LLM that you chose?" }),
    jsxRuntimeExports.jsxs(DialogFooter, { children: [
      jsxRuntimeExports.jsx(DialogButton, { text: "Not Now", onClick: onCancel }),
      jsxRuntimeExports.jsx(DialogButton, { text: "Refresh Page", onClick: onConfirm, isPrimary: true })
    ] })
  ] });
}
function SettingsDialog({ isOpen, defaultAppSettings, onClose, onLoadAppSettings, onSaveAppSettings, onValidateSetting }) {
  const initialAppSettingsRef = (0, import_react.useRef)(defaultAppSettings);
  const [categories, setCategories] = (0, import_react.useState)([]);
  const [selectedCategoryNo, setSelectedCategoryNo] = (0, import_react.useState)(0);
  const [categoryValidities, setCategoryValidities] = (0, import_react.useState)(Array(categories.length).fill(true));
  const [showRefreshDialog, setShowRefreshDialog] = (0, import_react.useState)(false);
  const [initialLlmValue, setInitialLlmValue] = (0, import_react.useState)(null);
  const categoryNames = (0, import_react.useMemo)(() => categories.map((c) => c.name), [categories]);
  function _updateCategory(categoryNo, nextCategory, isValid) {
    const nextCategoryValidities = [...categoryValidities];
    if (categoryValidities[categoryNo] !== isValid) {
      nextCategoryValidities[categoryNo] = isValid;
      setCategoryValidities(nextCategoryValidities);
    }
    const nextCategories = [...categories];
    nextCategories[categoryNo] = nextCategory;
    setCategories(nextCategories);
  }
  (0, import_react.useEffect)(() => {
    if (!isOpen) return;
    init$1(initialAppSettingsRef.current, onLoadAppSettings).then((initCategories) => {
      setCategories(initCategories);
      setSelectedCategoryNo(findOpeningCategoryNo(initCategories));
      const appCategory = initCategories[0];
      const llmSetting = appCategory.settings.find((s) => s.id === APP_SETTINGS_LLM_ID);
      setInitialLlmValue(llmSetting?.value ? String(llmSetting.value) : null);
    });
  }, [isOpen, onLoadAppSettings]);
  if (!isOpen || !categories.length) return null;
  const isSaveDisabled = categoryValidities.includes(false);
  function _handleSaveAndClose() {
    const appCategory = categories[0];
    const llmSetting = appCategory.settings.find((s) => s.id === APP_SETTINGS_LLM_ID);
    const currentLlmValue = llmSetting?.value ? String(llmSetting.value) : null;
    if (initialLlmValue !== currentLlmValue) {
      setShowRefreshDialog(true);
    } else {
      saveAndClose(categories, onClose, onSaveAppSettings);
    }
  }
  function _handleRefreshConfirm() {
    saveAndClose(categories, () => {
      onClose(categories[0].settings);
      window.location.reload();
    }, onSaveAppSettings);
  }
  function _handleRefreshCancel() {
    setShowRefreshDialog(false);
    saveAndClose(categories, onClose, onSaveAppSettings);
  }
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    jsxRuntimeExports.jsxs(ModalDialog, { title: "Device Settings", isOpen, onCancel: () => onClose(categories[0].settings), children: [
      jsxRuntimeExports.jsx(
        SettingsCategorySelector,
        {
          selectedCategoryNo,
          categoryNames,
          onChange: (nextCategoryNo) => {
            setSelectedCategoryNo(nextCategoryNo);
            setOpeningCategoryId(categories[nextCategoryNo].id);
          },
          disabled: isSaveDisabled
        }
      ),
      categories.map((category, categoryNo) => jsxRuntimeExports.jsx(
        SettingCategoryPanel,
        {
          category,
          isOpen: selectedCategoryNo === categoryNo,
          onValidateSetting,
          onChange: (nextCategory, isValid) => _updateCategory(categoryNo, nextCategory, isValid)
        },
        category.name
      )),
      jsxRuntimeExports.jsxs(DialogFooter, { children: [
        jsxRuntimeExports.jsx(DialogButton, { text: "Cancel", onClick: onClose }),
        jsxRuntimeExports.jsx(DialogButton, { text: "Save and Exit", onClick: _handleSaveAndClose, isPrimary: true, disabled: isSaveDisabled })
      ] })
    ] }),
    jsxRuntimeExports.jsx(
      PageRefreshConfirmDialog,
      {
        isOpen: showRefreshDialog,
        onConfirm: _handleRefreshConfirm,
        onCancel: _handleRefreshCancel
      }
    )
  ] });
}
var container = "_container_hyytp_4 _disableSelect_mpqe1_1";
var styles$2 = {
  container
};
var containerError = "_containerError_10gzw_26 _container_10gzw_3";
var containerInfo = "_containerInfo_10gzw_31 _container_10gzw_3";
var containerImportant = "_containerImportant_10gzw_36 _container_10gzw_3";
var containerAppear = "_containerAppear_10gzw_51";
var containerDisappear = "_containerDisappear_10gzw_56";
var dismissIcon = "_dismissIcon_10gzw_61";
var styles$1 = {
  containerError,
  containerInfo,
  containerImportant,
  containerAppear,
  containerDisappear,
  dismissIcon
};
function _getContainerStyleForType(type) {
  switch (type) {
    case ToastType.ERROR:
      return styles$1.containerError;
    case ToastType.IMPORTANT:
      return styles$1.containerImportant;
    default:
      return styles$1.containerInfo;
  }
}
function _getAnimationStyleForState(state) {
  switch (state) {
    case ToastState.APPEARING:
      return styles$1.containerAppear;
    case ToastState.DISAPPEARING:
      return styles$1.containerDisappear;
    default:
      return "";
  }
}
function ToastMessage(props) {
  const { onDismiss, toast, toastState } = props;
  const { message, type } = toast;
  const showDismissIcon = doesToastTypeRequireDismissing(type);
  const containerStyle = `${_getContainerStyleForType(type)} ${_getAnimationStyleForState(toastState)}`;
  const dismissIcon2 = showDismissIcon ? jsxRuntimeExports.jsx("div", { className: styles$1.dismissIcon, onClick: onDismiss, children: "âœ–" }) : null;
  return jsxRuntimeExports.jsxs("div", { className: containerStyle, onClick: onDismiss, children: [
    jsxRuntimeExports.jsx("p", { children: message }),
    dismissIcon2
  ] });
}
var toastIdCounter = 0;
var ANIMATION_INTERVAL_MSECS = 200;
var APPEAR_DURATION_MSECS = 1e3;
var MESSAGE_DURATION_MSECS = 5e3;
var DISAPPEAR_DURATION_MSECS = 1e3;
function _trackNewToast(toastsRef, newToast) {
  const oldToasts = toastsRef.current;
  const now2 = Date.now();
  const id = ++toastIdCounter;
  const requiresDismissing = doesToastTypeRequireDismissing(newToast.type);
  const newTrackedToast = { ...newToast, state: ToastState.APPEARING, lastStateTime: now2, id, requiresDismissing };
  toastsRef.current = [...oldToasts, newTrackedToast];
}
function _dismissToast(toastId, toastsRef) {
  const oldToasts = toastsRef.current;
  const now2 = Date.now();
  toastsRef.current = oldToasts.map((toast) => {
    if (toast.id !== toastId) return toast;
    if (toast.state === ToastState.DISAPPEARING) return { ...toast, requiresDismissing: false };
    return { ...toast, requiresDismissing: false, lastStateTime: now2, state: ToastState.DISAPPEARING };
  });
}
function _updateTrackedToastsForAnimation(toastsRef) {
  const oldToasts = toastsRef.current;
  const now2 = Date.now();
  let changed = false;
  const updatedToasts = oldToasts.map((toast) => {
    const { state, lastStateTime, requiresDismissing } = toast;
    const timeSinceLastState = now2 - lastStateTime;
    switch (state) {
      case ToastState.APPEARING:
        if (timeSinceLastState < APPEAR_DURATION_MSECS) return toast;
        changed = true;
        return { ...toast, state: ToastState.VISIBLE, lastStateTime: now2 };
      case ToastState.VISIBLE:
        if (requiresDismissing || timeSinceLastState < MESSAGE_DURATION_MSECS) return toast;
        changed = true;
        return { ...toast, state: ToastState.DISAPPEARING, lastStateTime: now2 };
      case ToastState.DISAPPEARING:
        if (timeSinceLastState < DISAPPEAR_DURATION_MSECS) return toast;
        changed = true;
        return { ...toast, state: ToastState.GONE, lastStateTime: now2 };
      default:
        return toast;
    }
  });
  if (changed) toastsRef.current = updatedToasts.filter((toast) => toast.state !== ToastState.GONE);
}
function ToastPane() {
  const toastsRef = (0, import_react.useRef)([]);
  const [frameNo, setFrameNo] = (0, import_react.useState)(0);
  const onNewToast = (newToast) => _trackNewToast(toastsRef, newToast);
  _updateTrackedToastsForAnimation(toastsRef);
  (0, import_react.useEffect)(() => {
    subscribeToToasts(onNewToast);
    return () => unsubscribeFromToasts(onNewToast);
  }, []);
  (0, import_react.useEffect)(() => {
    setTimeout(() => setFrameNo(frameNo + 1), ANIMATION_INTERVAL_MSECS);
  }, [frameNo, setFrameNo]);
  const renderedToasts = toastsRef.current.map((toast) => jsxRuntimeExports.jsx(ToastMessage, { toast, toastState: toast.state, onDismiss: () => _dismissToast(toast.id, toastsRef) }, toast.id));
  return jsxRuntimeExports.jsx("div", { className: styles$2.container, children: renderedToasts });
}
function _findFavIconLink() {
  return document.querySelector('link[rel~="icon"][sizes="192x192"]') || document.querySelector('link[rel~="icon"]');
}
async function init(appName2, enabledDomains, setModalDialogName) {
  try {
    initOpening(setModalDialogName);
    const loggingSettings = await getLoggingSettings();
    await applyLoggingSettings(loggingSettings);
    setAppName(appName2);
  } catch (e) {
    console.error("Error applying logging settings:", e);
  }
  let favIconUrl = null;
  const isDecentBarEnabled = isServingFromEnabledDomain(enabledDomains);
  const link = _findFavIconLink();
  favIconUrl = link ? link.href : null;
  return { isDecentBarEnabled, favIconUrl };
}
var DEFAULT_ENABLED_DOMAINS = ["decentapps.net", "127.0.0.1", "localhost"];
function defaultOnClickLink(link) {
  if (link.url.startsWith("http")) {
    const isSameDomain = link.url.startsWith(getBaseUrl());
    const target = isSameDomain ? "_self" : "_blank";
    window.open(link.url, target);
  } else {
    console.error('Link URL does not start with "http"--navigation canceled.', link.url);
  }
}
function _appLinksContent(links, onClickLink) {
  if (!links.length) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Â " });
  const linkButtons = links.map((link, buttonNo) => {
    return jsxRuntimeExports.jsx(ContentButton, { text: link.description, onClick: () => {
      onClickLink(link);
    } }, buttonNo);
  });
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    "Links:",
    jsxRuntimeExports.jsx("br", {}),
    linkButtons
  ] });
}
function _createDefaultAppSettings(appName2) {
  return {
    description: `These settings apply solely to ${appName2}, while other settings apply to all apps.`,
    settings: []
  };
}
function DecentBar({
  appName: appName2 = getAppName(),
  appLinks,
  contributorText,
  onClickLink = defaultOnClickLink,
  enabledDomains = DEFAULT_ENABLED_DOMAINS,
  homeUrl = getBaseUrl(),
  classNameOverrides = {},
  defaultAppSettings,
  onLoadAppSettings,
  onSaveAppSettings,
  onValidateSetting
}) {
  const initialAppSettings = (0, import_react.useRef)(defaultAppSettings || _createDefaultAppSettings(appName2));
  const [favIconUrl, setFavIconUrl] = (0, import_react.useState)(null);
  const [modalDialogName, setModalDialogName] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    init(appName2, enabledDomains, setModalDialogName).then((initResults) => {
      if (!initResults.isDecentBarEnabled) {
        console.log("DecentBar did not render because the current domain is not in the enabled domains list.");
        return;
      }
      if (!initResults.favIconUrl) {
        console.error("DecentBar did not render because no favicon image was set.");
        return;
      }
      setFavIconUrl(initResults.favIconUrl);
    });
  }, []);
  if (!favIconUrl) return null;
  const appLinksContent = _appLinksContent(appLinks || [], onClickLink);
  const containerClassName = `${styles$f.container} ${classNameOverrides?.container ?? ""}`;
  const decentFacetClassName = `${styles$f.decentFacet} ${classNameOverrides?.decentFacet ?? ""}`;
  const favIconClassName = `${styles$f.favIcon} ${classNameOverrides?.favIcon ?? ""}`;
  const appFacetClassName = `${styles$f.appFacet} ${classNameOverrides?.appFacet ?? ""}`;
  const appNameClassName = `${styles$f.appName} ${classNameOverrides?.appName ?? ""}`;
  const appButtonAreaClassName = `${styles$f.appButtonArea} ${classNameOverrides?.appButtonArea ?? ""}`;
  const appFacetSeparatorClassName = `${styles$f.appFacetSeparator} ${classNameOverrides?.appFacetSeparator ?? ""}`;
  const contributorFacetClassName = `${styles$f.contributorFacet} ${classNameOverrides?.contributorFacet ?? ""}`;
  const settingsIconClassName = `${styles$f.settingsIcon} ${classNameOverrides?.settingsIcon ?? ""}`;
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    jsxRuntimeExports.jsxs("div", { className: containerClassName, children: [
      jsxRuntimeExports.jsx("div", { className: decentFacetClassName, children: jsxRuntimeExports.jsx("a", { href: homeUrl, children: jsxRuntimeExports.jsx("img", { src: favIconUrl, className: favIconClassName, draggable: "false" }) }) }),
      jsxRuntimeExports.jsxs("div", { className: appFacetClassName, children: [
        jsxRuntimeExports.jsx("div", { className: appNameClassName, children: appName2 }),
        jsxRuntimeExports.jsx("div", { className: appButtonAreaClassName, children: appLinksContent })
      ] }),
      jsxRuntimeExports.jsx("div", { className: appFacetSeparatorClassName }),
      jsxRuntimeExports.jsxs("div", { className: contributorFacetClassName, children: [
        contributorText,
        jsxRuntimeExports.jsx("img", { src: SettingsIcon, className: settingsIconClassName, alt: "Device Settings", onClick: () => setModalDialogName(SettingsDialog.name) })
      ] })
    ] }),
    jsxRuntimeExports.jsx(
      SettingsDialog,
      {
        isOpen: modalDialogName === SettingsDialog.name,
        defaultAppSettings: initialAppSettings.current,
        onClose: () => setModalDialogName(null),
        onLoadAppSettings,
        onSaveAppSettings,
        onValidateSetting
      }
    ),
    jsxRuntimeExports.jsx(ToastPane, {})
  ] });
}
var continueText = "_continueText_rt9ep_4";
var modelIdText = "_modelIdText_rt9ep_8";
var problemPanel = "_problemPanel_rt9ep_16";
var styles = {
  continueText,
  modelIdText,
  problemPanel
};
async function findOtherModelCount(supportedModels) {
  if (!supportedModels) {
    const appMetaData = await getAppMetaData();
    supportedModels = appMetaData.supportedModels;
  }
  return Math.max(0, supportedModels.length - 1);
}
function _getOtherModelsAvailableText(otherModelCount) {
  if (otherModelCount === 0) return "";
  return otherModelCount === 1 ? " Another model supported by this app is available." : ` Other models supported by this app are available.`;
}
function _renderFooterButtons(hasBlockingProblem, otherModelCount, onCancel, onConfirm) {
  const buttons = [];
  if (otherModelCount > 0) {
    buttons.push(
      jsxRuntimeExports.jsx(DialogButton, { text: "Other Models", onClick: () => {
        onCancel();
        openSettingsDialog(APP_CATEGORY_ID);
      }, disabled: !otherModelCount }, "otherModels")
    );
  }
  buttons.push(
    jsxRuntimeExports.jsx(DialogButton, { text: "Cancel", onClick: onCancel, isPrimary: hasBlockingProblem }, "cancel")
  );
  if (!hasBlockingProblem) {
    buttons.push(
      jsxRuntimeExports.jsx(DialogButton, { text: "Load Model", onClick: onConfirm, isPrimary: true }, "loadModel")
    );
  }
  return buttons;
}
function ModelDeviceProblemsDialog({ isOpen, problems, onConfirm, onCancel, modelId, supportedModels }) {
  const [otherModelCount, setOtherModelCount] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    findOtherModelCount(supportedModels).then(setOtherModelCount);
  }, []);
  if (!isOpen || !problems || otherModelCount === null) return null;
  assert(problems.length >= 1);
  const isDeveloperMode = problems.length === 1 && problems[0].type === ModelDeviceProblemType.DEVELOPER_MODE;
  if (problems.length > 1) problems = problems.filter((p) => p.type !== ModelDeviceProblemType.DEVELOPER_MODE);
  const hasBlockingProblem = problems.some((p) => p.isBlocking);
  const summaryContent = isDeveloperMode ? jsxRuntimeExports.jsxs("p", { children: [
    "Development environment detected. Paused loading ",
    jsxRuntimeExports.jsx("span", { className: styles.modelIdText, children: modelId }),
    " until you confirm."
  ] }) : problems.length === 1 ? jsxRuntimeExports.jsxs("p", { children: [
    "The following problem was found for loading ",
    jsxRuntimeExports.jsx("span", { className: styles.modelIdText, children: modelId }),
    ":"
  ] }) : jsxRuntimeExports.jsxs("p", { children: [
    "The following problems were found for loading ",
    jsxRuntimeExports.jsx("span", { className: styles.modelIdText, children: modelId }),
    ":"
  ] });
  const otherModelsAvailableText = _getOtherModelsAvailableText(otherModelCount);
  const conclusionMessage = hasBlockingProblem ? `This model can't be loaded.${otherModelsAvailableText}` : `You can continue loading the model if you want.${otherModelsAvailableText}`;
  const footerButtons = _renderFooterButtons(hasBlockingProblem, otherModelCount, onCancel, onConfirm);
  return jsxRuntimeExports.jsxs(ModalDialog, { isOpen, title: hasBlockingProblem ? "Failed to Load Model" : "Continue Loading Model?", onCancel, children: [
    summaryContent,
    jsxRuntimeExports.jsx("div", { className: styles.problemPanel, children: jsxRuntimeExports.jsx(ModelDeviceProblemsList, { problems }) }),
    jsxRuntimeExports.jsx("p", { className: styles.continueText, children: conclusionMessage }),
    jsxRuntimeExports.jsx(DialogFooter, { children: footerButtons })
  ] });
}
export {
  APP_CATEGORY_ID,
  DecentBar,
  LLM_CATEGORY_ID,
  LOGGING_CATEGORY_ID,
  ModelDeviceProblemType,
  ModelDeviceProblemsDialog,
  SettingType,
  assert,
  assertNonNullable,
  assertTruthy,
  botch,
  defaultOnClickLink,
  errorToast,
  findBestModel,
  getAppId,
  getAppMetaData,
  getAppName,
  getAppSettings,
  importantToast,
  infoToast,
  initAppMetaData,
  log,
  openSettings,
  predictModelDeviceProblems,
  scoreModel,
  updateModelDeviceLoadHistory,
  updateModelDevicePerformanceHistory
};
/*! Bundled license information:

decent-portal/dist/decent-portal.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

decent-portal/dist/decent-portal.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=decent-portal.js.map
